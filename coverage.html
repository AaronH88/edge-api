
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>fdo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/redhatinsights/edge-api/pkg/clients/fdo/client.go (79.7%)</option>
				
				<option value="file1">github.com/redhatinsights/edge-api/pkg/clients/imagebuilder/client.go (29.5%)</option>
				
				<option value="file2">github.com/redhatinsights/edge-api/pkg/models/images.go (97.4%)</option>
				
				<option value="file3">github.com/redhatinsights/edge-api/pkg/models/thirdpartyrepo.go (0.0%)</option>
				
				<option value="file4">github.com/redhatinsights/edge-api/pkg/models/updates.go (0.0%)</option>
				
				<option value="file5">github.com/redhatinsights/edge-api/pkg/routes/common/account.go (0.0%)</option>
				
				<option value="file6">github.com/redhatinsights/edge-api/pkg/routes/common/filters.go (96.9%)</option>
				
				<option value="file7">github.com/redhatinsights/edge-api/pkg/routes/common/pagination.go (20.0%)</option>
				
				<option value="file8">github.com/redhatinsights/edge-api/pkg/routes/devices.go (31.2%)</option>
				
				<option value="file9">github.com/redhatinsights/edge-api/pkg/routes/images.go (26.3%)</option>
				
				<option value="file10">github.com/redhatinsights/edge-api/pkg/routes/imagesets.go (43.2%)</option>
				
				<option value="file11">github.com/redhatinsights/edge-api/pkg/routes/inventory.go (0.0%)</option>
				
				<option value="file12">github.com/redhatinsights/edge-api/pkg/routes/ok.go (100.0%)</option>
				
				<option value="file13">github.com/redhatinsights/edge-api/pkg/routes/ownershipvoucher.go (88.9%)</option>
				
				<option value="file14">github.com/redhatinsights/edge-api/pkg/routes/thirdpartyrepo.go (30.7%)</option>
				
				<option value="file15">github.com/redhatinsights/edge-api/pkg/routes/updates.go (8.2%)</option>
				
				<option value="file16">github.com/redhatinsights/edge-api/pkg/services/commits.go (0.0%)</option>
				
				<option value="file17">github.com/redhatinsights/edge-api/pkg/services/consumers.go (26.3%)</option>
				
				<option value="file18">github.com/redhatinsights/edge-api/pkg/services/devices.go (68.4%)</option>
				
				<option value="file19">github.com/redhatinsights/edge-api/pkg/services/errors.go (0.0%)</option>
				
				<option value="file20">github.com/redhatinsights/edge-api/pkg/services/files.go (40.9%)</option>
				
				<option value="file21">github.com/redhatinsights/edge-api/pkg/services/files/downloader.go (0.0%)</option>
				
				<option value="file22">github.com/redhatinsights/edge-api/pkg/services/files/extractor.go (70.8%)</option>
				
				<option value="file23">github.com/redhatinsights/edge-api/pkg/services/files/uploader.go (0.0%)</option>
				
				<option value="file24">github.com/redhatinsights/edge-api/pkg/services/images.go (12.1%)</option>
				
				<option value="file25">github.com/redhatinsights/edge-api/pkg/services/imagesets.go (18.5%)</option>
				
				<option value="file26">github.com/redhatinsights/edge-api/pkg/services/ownershipvoucher.go (95.3%)</option>
				
				<option value="file27">github.com/redhatinsights/edge-api/pkg/services/repo.go (5.9%)</option>
				
				<option value="file28">github.com/redhatinsights/edge-api/pkg/services/repobuilder.go (0.5%)</option>
				
				<option value="file29">github.com/redhatinsights/edge-api/pkg/services/thirdpartyrepo.go (0.0%)</option>
				
				<option value="file30">github.com/redhatinsights/edge-api/pkg/services/updates.go (56.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package fdo

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/edge-api/pkg/clients"
        log "github.com/sirupsen/logrus"
        "io"
        "net/http"
        "strconv"
)

// ClientInterface is an Interface to make request to FDO onboarding server
type ClientInterface interface {
        BatchUpload(ovs []byte, numOfOVs uint) (interface{}, error)
        BatchDelete(fdoUUIDList []string) (interface{}, error)
}

// Client is the implementation of an ClientInterface
type Client struct {
        ctx        context.Context
        log        *log.Entry
        httpClient *http.Client
}

// InitClient initializes the client for FDO
func InitClient(ctx context.Context, log *log.Entry) *Client <span class="cov10" title="3">{
        return &amp;Client{ctx: ctx, log: log, httpClient: &amp;http.Client{}}
}</span>

// BatchUpload used to batch upload ownershipvouchers, CBOR is self-describing, so it is possible
// to determine the end of the ownership voucher from its content
func (c *Client) BatchUpload(ovs []byte, numOfOVs uint) (interface{}, error) <span class="cov10" title="3">{
        if len(ovs) == 0 || numOfOVs == 0 </span><span class="cov1" title="1">{
                c.log.WithField("method", "fdo.BatchUpload").Error("No ownership vouchers provided")
                return nil, errors.New("no ownership vouchers provided")
        }</span>
        <span class="cov6" title="2">req, _ := reqUploadBuilder(c, ovs, numOfOVs) // build request
        res, err := c.httpClient.Do(req)
        // handle response
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithField("method", "fdo.BatchUpload").Error("Failed to perform api call to upload vouchers ", err)
                return nil, err
        }</span>
        <span class="cov6" title="2">return resUploadHandler(c, res)</span>
}

// BatchDelete used to batch delete ownershipvouchers, received as an array of
// FDO GUIDs, e.g.: [“a9bcd683-a7e4-46ed-80b2-6e55e8610d04”, “1ea69fcb-b784-4d0f-ab4d-94589c6cc7ad”]
func (c *Client) BatchDelete(fdoUUIDList []string) (interface{}, error) <span class="cov6" title="2">{
        if len(fdoUUIDList) == 0 </span><span class="cov1" title="1">{
                c.log.WithField("method", "fdo.BatchDelete").Error("No FDO UUIDs provided")
                return nil, errors.New("no FDO UUIDs provided")
        }</span>
        <span class="cov1" title="1">req, _ := reqDeleteBuilder(c, fdoUUIDList) // build request
        res, err := c.httpClient.Do(req)
        // handle response
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithField("method", "fdo.BatchDelete").Error("Failed to perform api call to remove vouchers ", err)
                return nil, err
        }</span>
        <span class="cov1" title="1">return resDeleteHandler(c, res)</span>
}

// Decode response body into json
func decodeResBody(body *io.ReadCloser) interface{} <span class="cov10" title="3">{
        var j interface{}
        json.NewDecoder(*body).Decode(&amp;j)
        return j
}</span>

// basic config for FDO
func basicConfig() (string, string, string) <span class="cov10" title="3">{
        host := config.Get().FDO.URL
        version := config.Get().FDO.APIVersion
        authorizationBearer := fmt.Sprint("Bearer ", config.Get().FDO.AuthorizationBearer)
        return host, version, authorizationBearer
}</span>

// build request for uploading ownershipvouchers
func reqUploadBuilder(c *Client, ovs []byte, numOfOVs uint) (*http.Request, error) <span class="cov6" title="2">{
        host, version, authorizationBearer := basicConfig()
        req, err := http.NewRequest(http.MethodPost, fmt.Sprintf("%s/management/%s/ownership_voucher", host, version), bytes.NewReader(ovs))
        req.Header.Add("Content-Type", "application/cbor")
        req.Header.Add("Authorization", authorizationBearer)
        req.Header.Add("X-Number-Of-Vouchers", strconv.FormatUint(uint64(numOfOVs), 10))
        req.Header.Add("Accept", "application/json")
        headers := clients.GetOutgoingHeaders(c.ctx)
        for key, value := range headers </span><span class="cov6" title="2">{
                req.Header.Add(key, value)
        }</span>
        <span class="cov6" title="2">return req, err</span>
}

// handle response for uploading ownershipvouchers
func resUploadHandler(c *Client, res *http.Response) (interface{}, error) <span class="cov6" title="2">{
        var err error
        defer res.Body.Close()
        switch res.StatusCode </span>{
        case http.StatusCreated:<span class="cov6" title="2">
                err = nil
                c.log.WithField("method", "fdo.resUploadHandler").Info("Ownershipvouchers got created successfully")</span>
        case http.StatusBadRequest:<span class="cov0" title="0">
                err = errors.New("bad request")
                c.log.WithField("method", "fdo.resUploadHandler").Error("Ownershipvouchers couldn't be created, bad request")</span>
        default:<span class="cov0" title="0">
                err = errors.New(fmt.Sprint("unknown error with status code: ", res.StatusCode))
                c.log.WithField("method", "fdo.resUploadHandler").Error("Ownershipvouchers couldn't be created, unknown error with status code: ", res.StatusCode)</span>
        }
        <span class="cov6" title="2">return decodeResBody(&amp;res.Body), err</span>
}

// build request for deleting ownershipvouchers
func reqDeleteBuilder(c *Client, fdoUUIDList []string) (*http.Request, error) <span class="cov1" title="1">{
        fdoUUIDListAsBytes, err := json.Marshal(fdoUUIDList)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithField("method", "fdo.reqDeleteBuilder").Error("Couldn't marshal FDO GUIDs into json")
                return nil, err
        }</span>
        <span class="cov1" title="1">host, version, authorizationBearer := basicConfig()
        req, err := http.NewRequest(http.MethodPost, fmt.Sprintf("%s/management/%s/ownership_voucher/delete", host, version), bytes.NewReader(fdoUUIDListAsBytes))
        req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Authorization", authorizationBearer)
        req.Header.Add("Accept", "application/json")
        headers := clients.GetOutgoingHeaders(c.ctx)
        for key, value := range headers </span><span class="cov1" title="1">{
                req.Header.Add(key, value)
        }</span>
        <span class="cov1" title="1">return req, err</span>
}

// handle response for deleting ownershipvouchers
func resDeleteHandler(c *Client, res *http.Response) (interface{}, error) <span class="cov1" title="1">{
        var err error
        defer res.Body.Close()
        switch res.StatusCode </span>{
        case http.StatusOK:<span class="cov1" title="1">
                err = nil
                c.log.WithField("method", "fdo.resDeleteHandler").Info("Ownershipvouchers got removed successfully")</span>
        case http.StatusBadRequest:<span class="cov0" title="0">
                err = errors.New("bad request")
                c.log.WithField("method", "fdo.resDeleteHandler").Error("Ownershipvouchers couldn't be removed, bad request")</span>
        default:<span class="cov0" title="0">
                err = errors.New(fmt.Sprint("unknown error with status code: ", res.StatusCode))
                c.log.WithField("method", "fdo.resDeleteHandler").Error("Ownershipvouchers couldn't be removed, unknown error with status code: ", res.StatusCode)</span>
        }
        <span class="cov1" title="1">return decodeResBody(&amp;res.Body), err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package imagebuilder

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "net/http"

        log "github.com/sirupsen/logrus"

        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/edge-api/pkg/clients"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"
)

// ClientInterface is an Interface to make request to ImageBuilder
type ClientInterface interface {
        ComposeCommit(image *models.Image) (*models.Image, error)
        ComposeInstaller(image *models.Image) (*models.Image, error)
        GetCommitStatus(image *models.Image) (*models.Image, error)
        GetInstallerStatus(image *models.Image) (*models.Image, error)
        GetMetadata(image *models.Image) (*models.Image, error)
}

// Client is the implementation of an ClientInterface
type Client struct {
        ctx context.Context
        log *log.Entry
}

// InitClient initializes the client for Image Builder
func InitClient(ctx context.Context, log *log.Entry) *Client <span class="cov10" title="4">{
        return &amp;Client{ctx: ctx, log: log}
}</span>

// A lot of this code comes from https://github.com/osbuild/osbuild-composer

// OSTree gives OSTree information for an image
type OSTree struct {
        URL string `json:"url,omitempty"`
        Ref string `json:"ref"`
}

// Customizations is made of the packages that are baked into an image
type Customizations struct {
        Packages *[]string `json:"packages"`
}

// UploadRequest is the upload options accepted by Image Builder API
type UploadRequest struct {
        Options interface{} `json:"options"`
        Type    string      `json:"type"`
}

// UploadTypes is the type that represents the types of uploads accepted by Image Builder
type UploadTypes string

// ImageRequest is image-related part of a ComposeRequest
type ImageRequest struct {
        Architecture  string         `json:"architecture"`
        ImageType     string         `json:"image_type"`
        Ostree        *OSTree        `json:"ostree,omitempty"`
        UploadRequest *UploadRequest `json:"upload_request"`
}

// ComposeRequest is the request to Compose one or more Images
type ComposeRequest struct {
        Customizations *Customizations `json:"customizations"`
        Distribution   string          `json:"distribution"`
        ImageRequests  []ImageRequest  `json:"image_requests"`
}

// ComposeStatus is the status of a ComposeRequest
type ComposeStatus struct {
        ImageStatus ImageStatus `json:"image_status"`
}

// ImageStatus is the status of the upload of an Image
type ImageStatus struct {
        Status       imageStatusValue `json:"status"`
        UploadStatus *UploadStatus    `json:"upload_status,omitempty"`
}

type imageStatusValue string

const (
        imageStatusBulding     imageStatusValue = "building"
        imageStatusFailure     imageStatusValue = "failure"
        imageStatusPending     imageStatusValue = "pending"
        imageStatusRegistering imageStatusValue = "registering"
        imageStatusSuccess     imageStatusValue = "success"
        imageStatusUploading   imageStatusValue = "uploading"
)

// UploadStatus is the status and metadata of an Image upload
type UploadStatus struct {
        Options S3UploadStatus `json:"options"`
        Status  string         `json:"status"`
        Type    UploadTypes    `json:"type"`
}

// ComposeResult has the ID of a ComposeRequest
type ComposeResult struct {
        ID string `json:"id"`
}

// S3UploadStatus contains the URL to the S3 Bucket
type S3UploadStatus struct {
        URL string `json:"url"`
}

// Metadata struct to get the metadata response
type Metadata struct {
        OstreeCommit      string             `json:"ostree_commit"`
        InstalledPackages []InstalledPackage `json:"packages"`
}

// InstalledPackage contains the metadata of the packages installed on a image
type InstalledPackage struct {
        Arch      string `json:"arch"`
        Name      string `json:"name"`
        Release   string `json:"release"`
        Sigmd5    string `json:"sigmd5"`
        Signature string `json:"signature"`
        Type      string `json:"type"`
        Version   string `json:"version"`
        Epoch     string `json:"epoch,omitempty"`
}

func (c *Client) compose(composeReq *ComposeRequest) (*ComposeResult, error) <span class="cov8" title="3">{
        payloadBuf := new(bytes.Buffer)
        json.NewEncoder(payloadBuf).Encode(composeReq)
        cfg := config.Get()
        url := fmt.Sprintf("%s/api/image-builder/v1/compose", cfg.ImageBuilderConfig.URL)
        c.log.WithFields(log.Fields{
                "url":     url,
                "payload": payloadBuf.String(),
        }).Info("Image Builder Compose Request Started")
        req, _ := http.NewRequest("POST", url, payloadBuf)
        for key, value := range clients.GetOutgoingHeaders(c.ctx) </span><span class="cov8" title="3">{
                req.Header.Add(key, value)
        }</span>
        <span class="cov8" title="3">req.Header.Add("Content-Type", "application/json")

        client := &amp;http.Client{}
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                var code int
                if res != nil </span><span class="cov0" title="0">{
                        code = res.StatusCode
                }</span>
                <span class="cov0" title="0">c.log.WithFields(log.Fields{
                        "statusCode": code,
                        "error":      err,
                }).Error("Image Builder Compose Request Error")
                return nil, err</span>
        }
        <span class="cov8" title="3">respBody, err := ioutil.ReadAll(res.Body)
        c.log.WithFields(log.Fields{
                "statusCode":   res.StatusCode,
                "responseBody": string(respBody),
                "error":        err,
        }).Info("Image Builder Compose Response")

        if res.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("image is not being created by image builder")
        }</span>

        <span class="cov8" title="3">if err != nil </span><span class="cov0" title="0">{
                c.log.Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="3">cr := &amp;ComposeResult{}
        err = json.Unmarshal(respBody, &amp;cr)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="3">defer res.Body.Close()
        return cr, nil</span>
}

// ComposeCommit composes a Commit on ImageBuilder
func (c *Client) ComposeCommit(image *models.Image) (*models.Image, error) <span class="cov5" title="2">{
        req := &amp;ComposeRequest{
                Customizations: &amp;Customizations{
                        Packages: image.GetPackagesList(),
                },

                Distribution: image.Distribution,
                ImageRequests: []ImageRequest{
                        {
                                Architecture: image.Commit.Arch,
                                ImageType:    models.ImageTypeCommit,
                                UploadRequest: &amp;UploadRequest{
                                        Options: make(map[string]string),
                                        Type:    "aws.s3",
                                },
                        }},
        }
        if image.Commit.OSTreeRef != "" </span><span class="cov0" title="0">{
                if req.ImageRequests[0].Ostree == nil </span><span class="cov0" title="0">{
                        req.ImageRequests[0].Ostree = &amp;OSTree{}
                }</span>
                <span class="cov0" title="0">req.ImageRequests[0].Ostree.Ref = image.Commit.OSTreeRef</span>
        }
        <span class="cov5" title="2">if image.Commit.OSTreeParentCommit != "" </span><span class="cov0" title="0">{
                if req.ImageRequests[0].Ostree == nil </span><span class="cov0" title="0">{
                        req.ImageRequests[0].Ostree = &amp;OSTree{}
                }</span>
                <span class="cov0" title="0">req.ImageRequests[0].Ostree.URL = image.Commit.OSTreeParentCommit</span>
        }

        <span class="cov5" title="2">cr, err := c.compose(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">image.Commit.ComposeJobID = cr.ID
        image.Commit.Status = models.ImageStatusBuilding
        image.Status = models.ImageStatusBuilding
        return image, nil</span>
}

// ComposeInstaller composes a Installer on ImageBuilder
func (c *Client) ComposeInstaller(image *models.Image) (*models.Image, error) <span class="cov1" title="1">{
        pkgs := make([]string, 0)
        req := &amp;ComposeRequest{
                Customizations: &amp;Customizations{
                        Packages: &amp;pkgs,
                },

                Distribution: image.Distribution,
                ImageRequests: []ImageRequest{
                        {
                                Architecture: image.Commit.Arch,
                                ImageType:    models.ImageTypeInstaller,
                                Ostree: &amp;OSTree{
                                        Ref: "rhel/8/x86_64/edge", //image.Commit.OSTreeRef,
                                        URL: image.Commit.Repo.URL,
                                },
                                UploadRequest: &amp;UploadRequest{
                                        Options: make(map[string]string),
                                        Type:    "aws.s3",
                                },
                        }},
        }
        cr, err := c.compose(req)
        if err != nil </span><span class="cov0" title="0">{
                image.Installer.Status = models.ImageStatusError
                image.Status = models.ImageStatusError
                tx := db.DB.Save(&amp;image)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        log.Error(tx.Error)
                }</span>
                <span class="cov0" title="0">tx = db.DB.Save(&amp;image.Installer)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        log.Error(tx.Error)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov1" title="1">image.Installer.ComposeJobID = cr.ID
        image.Installer.Status = models.ImageStatusBuilding
        image.Status = models.ImageStatusBuilding
        tx := db.DB.Save(&amp;image)
        if tx.Error != nil </span><span class="cov1" title="1">{
                log.Error(tx.Error)
        }</span>
        <span class="cov1" title="1">tx = db.DB.Save(&amp;image.Installer)
        if tx.Error != nil </span><span class="cov0" title="0">{
                log.Error(tx.Error)
        }</span>
        <span class="cov1" title="1">return image, nil</span>
}

func (c *Client) getComposeStatus(jobID string) (*ComposeStatus, error) <span class="cov0" title="0">{
        cs := &amp;ComposeStatus{}
        cfg := config.Get()
        url := fmt.Sprintf("%s/api/image-builder/v1/composes/%s", cfg.ImageBuilderConfig.URL, jobID)
        c.log.WithFields(log.Fields{
                "url": url,
        }).Info("Image Builder ComposeStatus Request Started")
        req, _ := http.NewRequest("GET", url, nil)
        for key, value := range clients.GetOutgoingHeaders(c.ctx) </span><span class="cov0" title="0">{
                req.Header.Add(key, value)
        }</span>
        <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")
        client := &amp;http.Client{}
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithFields(log.Fields{
                        "statusCode": res.StatusCode,
                        "error":      err,
                }).Error("Image Builder ComposeStatus Request Error")
                return nil, err
        }</span>
        <span class="cov0" title="0">respBody, err := ioutil.ReadAll(res.Body)
        c.log.WithFields(log.Fields{
                "statusCode":   res.StatusCode,
                "responseBody": string(respBody),
                "error":        err,
        }).Info("Image Builder ComposeStatus Response")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if res.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request for status was not successful")
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(respBody, &amp;cs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer res.Body.Close()
        return cs, nil</span>
}

// GetCommitStatus gets the Commit status on Image Builder
func (c *Client) GetCommitStatus(image *models.Image) (*models.Image, error) <span class="cov0" title="0">{
        cs, err := c.getComposeStatus(image.Commit.ComposeJobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if cs.ImageStatus.Status == imageStatusSuccess </span><span class="cov0" title="0">{
                c.log.Info("Set image status with success")
                image.Commit.Status = models.ImageStatusSuccess
                image.Commit.ImageBuildTarURL = cs.ImageStatus.UploadStatus.Options.URL
        }</span> else<span class="cov0" title="0"> if cs.ImageStatus.Status == imageStatusFailure </span><span class="cov0" title="0">{
                c.log.Info("Set image status with error")
                image.Commit.Status = models.ImageStatusError
                image.Status = models.ImageStatusError
        }</span>
        <span class="cov0" title="0">return image, nil</span>
}

// GetInstallerStatus gets the Installer status on Image Builder
func (c *Client) GetInstallerStatus(image *models.Image) (*models.Image, error) <span class="cov0" title="0">{
        cs, err := c.getComposeStatus(image.Installer.ComposeJobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c.log.Info(fmt.Sprintf("Got installer status %s", cs.ImageStatus.Status))
        if cs.ImageStatus.Status == imageStatusSuccess </span><span class="cov0" title="0">{
                image.Installer.Status = models.ImageStatusSuccess
                image.Installer.ImageBuildISOURL = cs.ImageStatus.UploadStatus.Options.URL
        }</span> else<span class="cov0" title="0"> if cs.ImageStatus.Status == imageStatusFailure </span><span class="cov0" title="0">{
                image.Installer.Status = models.ImageStatusError
                image.Status = models.ImageStatusError
        }</span>
        <span class="cov0" title="0">return image, nil</span>
}

// GetMetadata returns the metadata on image builder for a particular image based on the ComposeJobID
func (c *Client) GetMetadata(image *models.Image) (*models.Image, error) <span class="cov0" title="0">{
        c.log.Infof("Getting metadata for image")
        composeJobID := image.Commit.ComposeJobID
        cfg := config.Get()
        url := fmt.Sprintf("%s/api/image-builder/v1/composes/%s/metadata", cfg.ImageBuilderConfig.URL, composeJobID)
        c.log.WithFields(log.Fields{
                "url": url,
        }).Info("Image Builder GetMetadata Request Started")
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for key, value := range clients.GetOutgoingHeaders(c.ctx) </span><span class="cov0" title="0">{
                req.Header.Add(key, value)
        }</span>
        <span class="cov0" title="0">req.Header.Add("Content-Type", "application/json")
        client := &amp;http.Client{}
        res, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c.log.WithFields(log.Fields{
                        "statusCode": res.StatusCode,
                        "error":      err,
                }).Error("Image Builder GetMetadata Request Error")
                return nil, err
        }</span>
        <span class="cov0" title="0">respBody, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        c.log.WithFields(log.Fields{
                "statusCode":   res.StatusCode,
                "responseBody": string(respBody),
                "error":        err,
        }).Info("Image Builder GetMetadata Response")
        if res.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, errors.New("image metadata not found")
        }</span>

        <span class="cov0" title="0">var metadata Metadata
        json.Unmarshal(respBody, &amp;metadata)
        for n := range metadata.InstalledPackages </span><span class="cov0" title="0">{
                pkg := models.InstalledPackage{
                        Arch: metadata.InstalledPackages[n].Arch, Name: metadata.InstalledPackages[n].Name,
                        Release: metadata.InstalledPackages[n].Release, Sigmd5: metadata.InstalledPackages[n].Sigmd5,
                        Signature: metadata.InstalledPackages[n].Signature, Type: metadata.InstalledPackages[n].Type,
                        Version: metadata.InstalledPackages[n].Version, Epoch: metadata.InstalledPackages[n].Epoch,
                }
                image.Commit.InstalledPackages = append(image.Commit.InstalledPackages, pkg)
        }</span>
        <span class="cov0" title="0">image.Commit.OSTreeCommit = metadata.OstreeCommit
        c.log.Infof("Done with metadata for image")
        return image, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "errors"
        "regexp"

        "github.com/lib/pq"
        "github.com/redhatinsights/edge-api/pkg/db"
)

// ImageSet represents a collection of images
type ImageSet struct {
        Model
        Name    string  `json:"Name"`
        Version int     `json:"Version" gorm:"default:1"`
        Account string  `json:"Account"`
        Images  []Image `json:"Images"`
}

// Image is what generates a OSTree Commit.
type Image struct {
        Model
        Name         string         `json:"Name"`
        Account      string         `json:"Account"`
        Distribution string         `json:"Distribution"`
        Description  string         `json:"Description"`
        Status       string         `json:"Status"`
        Version      int            `json:"Version" gorm:"default:1"`
        ImageType    string         `json:"ImageType"` // TODO: Remove as soon as the frontend stops using
        OutputTypes  pq.StringArray `gorm:"type:text[]" json:"OutputTypes"`
        CommitID     uint           `json:"CommitID"`
        Commit       *Commit        `json:"Commit"`
        InstallerID  *uint          `json:"InstallerID"`
        Installer    *Installer     `json:"Installer"`
        ImageSetID   *uint          `json:"ImageSetID"` // TODO: Wipe staging database and set to not nullable
        Packages     []Package      `json:"Packages" gorm:"many2many:images_packages;"`
}

const (
        // DistributionCantBeNilMessage is the error message when a distribution is nil
        DistributionCantBeNilMessage = "distribution can't be empty"
        // ArchitectureCantBeEmptyMessage is the error message when the architecture is empty
        ArchitectureCantBeEmptyMessage = "architecture can't be empty"
        // NameCantBeInvalidMessage is the error message when the name is invalid
        NameCantBeInvalidMessage = "name must start with alphanumeric characters and can contain underscore and hyphen characters"
        // ImageTypeNotAccepted is the error message when an image type is not accepted
        ImageTypeNotAccepted = "this image type is not accepted"
        // ImageNameAlreadyExists is the error message when an image name alredy exists
        ImageNameAlreadyExists = "this image name is already in use"
        // NoOutputTypes is the error message when the output types list is empty
        NoOutputTypes = "an output type is required"

        // ImageTypeInstaller is the installer image type on Image Builder
        ImageTypeInstaller = "rhel-edge-installer"
        // ImageTypeCommit is the installer image type on Image Builder
        ImageTypeCommit = "rhel-edge-commit"

        // ImageStatusCreated is for when a image is created
        ImageStatusCreated = "CREATED"
        // ImageStatusBuilding is for when a image is building
        ImageStatusBuilding = "BUILDING"
        // ImageStatusError is for when a image is on a error state
        ImageStatusError = "ERROR"
        // ImageStatusSuccess is for when a image is available to the user
        ImageStatusSuccess = "SUCCESS"

        // MissingInstaller is the error message for not passing an installer in the request
        MissingInstaller = "installer info must be provided"
        // MissingUsernameError is the error message for not passing username in the request
        MissingUsernameError = "username must be provided"
        // MissingSSHKeyError is the error message when SSH Key is not given
        MissingSSHKeyError = "SSH key must be provided"
        // InvalidSSHKeyError is the error message for not supported or invalid ssh key format
        InvalidSSHKeyError = "SSH Key supports RSA or DSS or ED25519 or ECDSA-SHA2 algorithms"
)

// Required Packages to send to image builder that will go into the base image
var requiredPackages = [6]string{
        "ansible",
        "rhc",
        "rhc-worker-playbook",
        "subscription-manager",
        "subscription-manager-plugin-ostree",
        "insights-client",
}

var (
        validSSHPrefix     = regexp.MustCompile(`^(ssh-(rsa|dss|ed25519)|ecdsa-sha2-nistp(256|384|521)) \S+`)
        validImageName     = regexp.MustCompile(`^[A-Za-z0-9]+[A-Za-z0-9\s_-]*$`)
        acceptedImageTypes = map[string]interface{}{ImageTypeCommit: nil, ImageTypeInstaller: nil}
)

// ValidateRequest validates an Image Request
func (i *Image) ValidateRequest() error <span class="cov10" title="16">{
        if i.Distribution == "" </span><span class="cov1" title="1">{
                return errors.New(DistributionCantBeNilMessage)
        }</span>
        <span class="cov9" title="15">if !validImageName.MatchString(i.Name) </span><span class="cov3" title="2">{
                return errors.New(NameCantBeInvalidMessage)
        }</span>
        <span class="cov9" title="13">if i.Commit == nil || i.Commit.Arch == "" </span><span class="cov4" title="3">{
                return errors.New(ArchitectureCantBeEmptyMessage)
        }</span>
        <span class="cov8" title="10">if len(i.OutputTypes) == 0 </span><span class="cov1" title="1">{
                return errors.New(NoOutputTypes)
        }</span>
        <span class="cov8" title="9">for _, out := range i.OutputTypes </span><span class="cov8" title="9">{
                if _, ok := acceptedImageTypes[out]; !ok </span><span class="cov1" title="1">{
                        return errors.New(ImageTypeNotAccepted)
                }</span>
        }
        <span class="cov7" title="8">if i.Version == 1 &amp;&amp; checkIfImageExist(i.Name) </span><span class="cov1" title="1">{
                return errors.New(ImageNameAlreadyExists)
        }</span>

        // Installer checks
        <span class="cov7" title="7">if i.HasOutputType(ImageTypeInstaller) </span><span class="cov6" title="5">{
                if i.Installer == nil </span><span class="cov1" title="1">{
                        return errors.New(MissingInstaller)
                }</span>
                <span class="cov5" title="4">if i.Installer.Username == "" </span><span class="cov1" title="1">{
                        return errors.New(MissingUsernameError)
                }</span>
                <span class="cov4" title="3">if i.Installer.SSHKey == "" </span><span class="cov1" title="1">{
                        return errors.New(MissingSSHKeyError)
                }</span>
                <span class="cov3" title="2">if !validSSHPrefix.MatchString(i.Installer.SSHKey) </span><span class="cov1" title="1">{
                        return errors.New(InvalidSSHKeyError)
                }</span>

        }
        <span class="cov4" title="3">return nil</span>
}

// HasOutputType checks if an image has an specific output type
func (i *Image) HasOutputType(imageType string) bool <span class="cov7" title="7">{
        for _, out := range i.OutputTypes </span><span class="cov7" title="7">{
                if out == imageType </span><span class="cov6" title="5">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

// GetPackagesList returns the packages in a user-friendly list containing their names
func (i *Image) GetPackagesList() *[]string <span class="cov1" title="1">{
        l := len(requiredPackages)
        pkgs := make([]string, len(i.Packages)+l)
        for i, p := range requiredPackages </span><span class="cov6" title="6">{
                pkgs[i] = p
        }</span>
        <span class="cov1" title="1">for i, p := range i.Packages </span><span class="cov3" title="2">{
                pkgs[i+l] = p.Name
        }</span>
        <span class="cov1" title="1">return &amp;pkgs</span>
}

//checkIfImageExist checks if name to image is already in use
func checkIfImageExist(imageName string) bool <span class="cov1" title="1">{
        var imageFindByName *Image
        result := db.DB.Where("Name = ?", imageName).First(&amp;imageFindByName)
        if result.Error != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">return imageFindByName != nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "errors"
        "regexp"
)

/*
ThirdPartyRepo is a record of Third Party Repository or we can call it as Custom Repository provided by customers per account.

        Here, URL refers to the url of the third party repository, Account refers to the account attached to the third party
        repository.

*/
type ThirdPartyRepo struct {
        Model
        Name        string `json:"Name" gorm:"uniqueIndex"`
        URL         string `json:"URL"`
        Description string `json:"Description,omitempty"`
        Account     string
}

const (
        // RepoNameCantBeInvalidMessage is the error message when the name is invalid
        RepoNameCantBeInvalidMessage = "name must start with alphanumeric characters and can contain underscore and hyphen characters"
        // RepoURLCantBeNilMessage is the error message when Repository url is nil
        RepoURLCantBeNilMessage = "repository URL can't be empty"
        // RepoNameCantBeNilMessage is the error when Repository name is nil
        RepoNameCantBeNilMessage = "repository name can't be empty"
)

var (
        validRepoName = regexp.MustCompile(`^[A-Za-z0-9]+[A-Za-z0-9\s_-]*$`)
)

// ValidateRequest validates the Repository Request
func (t *ThirdPartyRepo) ValidateRequest() error <span class="cov0" title="0">{
        if t.Name == "" </span><span class="cov0" title="0">{
                return errors.New(RepoNameCantBeNilMessage)
        }</span>
        <span class="cov0" title="0">if t.URL == "" </span><span class="cov0" title="0">{
                return errors.New(RepoURLCantBeNilMessage)
        }</span>
        <span class="cov0" title="0">if !validRepoName.MatchString(t.Name) </span><span class="cov0" title="0">{
                return errors.New(RepoNameCantBeInvalidMessage)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "errors"
)

// Device is a record of Edge Devices referenced by their UUID as per the
// cloud.redhat.com Inventory.
//
//        Connected refers to the devices Cloud Connector state, 0 is unavailable
//        and 1 is reachable.
type Device struct {
        Model
        UUID        string `json:"UUID"`
        DesiredHash string `json:"DesiredHash"`
        RHCClientID string `json:"RHCClientID"`
        Connected   bool   `gorm:"default:true" json:"Connected"`
}

// UpdateTransaction represents the combination of an OSTree commit and a set of Inventory
//        hosts that need to have the commit deployed to them
//
//        This will ultimately kick off a transaction where the old version(s) of
//        OSTree commit that are currently deployed onto those devices are combined
//        with the new commit into a new OSTree repo, static deltas are computed, and
//        then the result is stored in a way that can be served(proxied) by a
//        Server (pkg/repo/server.go).
type UpdateTransaction struct {
        Model
        Commit          *Commit          `json:"Commit"`
        CommitID        uint             `json:"CommitID"`
        Account         string           `json:"Account"`
        OldCommits      []Commit         `gorm:"many2many:updatetransaction_commits;" json:"OldCommits"`
        Devices         []Device         `gorm:"many2many:updatetransaction_devices;" json:"Devices"`
        Tag             string           `json:"Tag"`
        Status          string           `json:"Status"`
        RepoID          uint             `json:"RepoID"`
        Repo            *Repo            `json:"Repo"`
        DispatchRecords []DispatchRecord `gorm:"many2many:updatetransaction_dispatchrecords;" json:"DispatchRecords"`
}

// DispatchRecord represents the combination of a Playbook Dispatcher (https://github.com/RedHatInsights/playbook-dispatcher),
// of a PlaybookURL, a pointer to a Device, and the status.
// This is used within UpdateTransaction for accounting purposes.
type DispatchRecord struct {
        Model
        PlaybookURL          string  `json:"PlaybookURL"`
        DeviceID             uint    `json:"DeviceID"`
        Device               *Device `json:"Device"`
        Status               string  `json:"Status"`
        PlaybookDispatcherID string  `json:"PlaybookDispatcherID"`
}

const (
        // DevicesCantBeEmptyMessage is the error message when the hosts are empty
        DevicesCantBeEmptyMessage = "devices can not be empty"

        // UpdateStatusCreated is for when a update is created
        UpdateStatusCreated = "CREATED"
        // UpdateStatusBuilding is for when a update is building
        UpdateStatusBuilding = "BUILDING"
        // UpdateStatusError is for when a update is on a error state
        UpdateStatusError = "ERROR"
        // UpdateStatusSuccess is for when a update is available to the user
        UpdateStatusSuccess = "SUCCESS"
)

const (
        // DispatchRecordStatusCreated is for when a the DispatchRecord is created
        DispatchRecordStatusCreated = "CREATED"
        // DispatchRecordStatusPending is for when a UpdateTransaction has started
        //                scheduling PlaybookDispatcher jobs but this one hasn't started yet
        DispatchRecordStatusPending = "PENDING"
        // DispatchRecordStatusRunning is for when a the DispatchRecord is running
        DispatchRecordStatusRunning = "RUNNING"
        // DispatchRecordStatusError is for when a playbook dispatcher job is in a error state
        DispatchRecordStatusError = "ERROR"
        // DispatchRecordStatusComplete is for when a playbook dispatcher job is complete
        DispatchRecordStatusComplete = "COMPLETE"
)

// ValidateRequest validates a Update Record Request
func (ur *UpdateTransaction) ValidateRequest() error <span class="cov0" title="0">{
        if ur.Devices == nil || len(ur.Devices) == 0 </span><span class="cov0" title="0">{
                return errors.New(DevicesCantBeEmptyMessage)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package common

import (
        "context"
        "fmt"
        "net/http"

        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/platform-go-middlewares/identity"
)

// GetAccount from http request header
func GetAccount(r *http.Request) (string, error) <span class="cov0" title="0">{
        return GetAccountFromContext(r.Context())
}</span>

// GetAccountFromContext determines account number from supplied context
func GetAccountFromContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        if config.Get() != nil </span><span class="cov0" title="0">{
                if !config.Get().Auth </span><span class="cov0" title="0">{
                        return "0000000", nil
                }</span>
                <span class="cov0" title="0">if ctx.Value(identity.Key) != nil </span><span class="cov0" title="0">{
                        ident := identity.Get(ctx)
                        if ident.Identity.AccountNumber != "" </span><span class="cov0" title="0">{
                                return ident.Identity.AccountNumber, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return "", fmt.Errorf("cannot find account number")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package common

import (
        "fmt"
        "net/http"
        "strings"
        "time"

        "gorm.io/gorm"
)

// FilterFunc is a function that takes http request and GORM DB adds a query according to the request
type FilterFunc func(r *http.Request, tx *gorm.DB) *gorm.DB

// Filter is the struct that defines an API Filter
type Filter struct {
        QueryParam string
        DBField    string
}

// ContainFilterHandler handles sub string values
func ContainFilterHandler(filter *Filter) FilterFunc <span class="cov4" title="2">{
        sqlQuery := fmt.Sprintf("%s LIKE ?", filter.DBField)
        return FilterFunc(func(r *http.Request, tx *gorm.DB) *gorm.DB </span><span class="cov6" title="3">{
                if val := r.URL.Query().Get(filter.QueryParam); val != "" </span><span class="cov6" title="3">{
                        tx = tx.Where(sqlQuery, "%"+val+"%")
                }</span>
                <span class="cov6" title="3">return tx</span>
        })
}

// OneOfFilterHandler handles multiple values filters
func OneOfFilterHandler(filter *Filter) FilterFunc <span class="cov1" title="1">{
        sqlQuery := fmt.Sprintf("%s IN ?", filter.DBField)
        return FilterFunc(func(r *http.Request, tx *gorm.DB) *gorm.DB </span><span class="cov1" title="1">{
                if vals, ok := r.URL.Query()[filter.QueryParam]; ok </span><span class="cov1" title="1">{
                        tx = tx.Where(sqlQuery, vals)
                }</span>
                <span class="cov1" title="1">return tx</span>
        })
}

// LayoutISO represent the date layout in the API query
const LayoutISO = "2006-01-02"

// CreatedAtFilterHandler handles the "created_at" filter
func CreatedAtFilterHandler(filter *Filter) FilterFunc <span class="cov1" title="1">{
        return FilterFunc(func(r *http.Request, tx *gorm.DB) *gorm.DB </span><span class="cov1" title="1">{
                if val := r.URL.Query().Get(filter.QueryParam); val != "" </span><span class="cov1" title="1">{
                        currentDay, err := time.Parse(LayoutISO, val)
                        if err != nil </span><span class="cov0" title="0">{
                                return tx
                        }</span>
                        <span class="cov1" title="1">nextDay := currentDay.Add(time.Hour * 24)
                        tx = tx.Where("%s BETWEEN ? AND ?", filter.DBField, currentDay.Format(LayoutISO), nextDay.Format(LayoutISO))</span>
                }
                <span class="cov1" title="1">return tx</span>
        })
}

// SortFilterHandler handles sorting
func SortFilterHandler(sortTable, defaultSortKey, defaultOrder string) FilterFunc <span class="cov1" title="1">{
        return FilterFunc(func(r *http.Request, tx *gorm.DB) *gorm.DB </span><span class="cov4" title="2">{
                sortBy := defaultSortKey
                sortOrder := defaultOrder
                if val := r.URL.Query().Get("sort_by"); val != "" </span><span class="cov4" title="2">{
                        if strings.HasPrefix(val, "-") </span><span class="cov1" title="1">{
                                sortOrder = "DESC"
                                sortBy = val[1:]
                        }</span> else<span class="cov1" title="1"> {
                                sortOrder = "ASC"
                                sortBy = val
                        }</span>
                }
                <span class="cov4" title="2">return tx.Order(fmt.Sprintf("%s.%s %s", sortTable, sortBy, sortOrder))</span>
        })
}

// ComposeFilters composes all the filters into one function
func ComposeFilters(fs ...FilterFunc) FilterFunc <span class="cov7" title="4">{
        return func(r *http.Request, tx *gorm.DB) *gorm.DB </span><span class="cov8" title="5">{
                for _, f := range fs </span><span class="cov10" title="7">{
                        tx = f(r, tx)
                }</span>
                <span class="cov8" title="5">return tx</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package common

import (
        "context"
        "net/http"
        "strconv"

        "github.com/redhatinsights/edge-api/pkg/errors"
)

type paginationContextKey int

const (
        // PaginationKey is used to store pagination data in request context
        PaginationKey paginationContextKey = 1
        defaultLimit  int                  = 100
        defaultOffset int                  = 0
)

// Pagination represents pagination parameters
type Pagination struct {
        // Limit represents how many items to return
        Limit int
        // Offset represents from what item to start
        Offset int
}

// EdgeAPIPaginatedResponse represents pagination response
type EdgeAPIPaginatedResponse struct {
        Count int64
        Data  interface{}
}

// ValidationError represents validation error
type ValidationError struct {
        Key    string
        Reason string
}

// Paginate is a middleware to get pagination params from the request and store it in
// the request context. If no pagination was set in the request URL search parameters
// they are set to default (see defaultLimit and defaultOffset).
// To read pagination parameters from context use PaginationKey.
func Paginate(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                pagination := Pagination{Limit: defaultLimit, Offset: defaultOffset}
                if val, ok := r.URL.Query()["limit"]; ok </span><span class="cov0" title="0">{
                        valInt, err := strconv.Atoi(val[0])
                        if err != nil </span><span class="cov0" title="0">{
                                errors.NewBadRequest(err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">pagination.Limit = valInt</span>
                }
                <span class="cov0" title="0">if val, ok := r.URL.Query()["offset"]; ok </span><span class="cov0" title="0">{
                        valInt, err := strconv.Atoi(val[0])
                        if err != nil </span><span class="cov0" title="0">{
                                errors.NewBadRequest(err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">pagination.Offset = valInt</span>
                }
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), PaginationKey, pagination)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GetPagination is a function helper to get pagination parameters from the request context.
// In case the router doesn't use Paginate before serving the request we still return
// the default parameters: defaultOffset, defaultLimit
func GetPagination(r *http.Request) Pagination <span class="cov10" title="2">{
        pagination, ok := r.Context().Value(PaginationKey).(Pagination)
        if !ok </span><span class="cov1" title="1">{
                return Pagination{Offset: defaultOffset, Limit: defaultLimit}
        }</span>
        <span class="cov1" title="1">return pagination</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package routes

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/go-chi/chi"
        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/services"
        "github.com/redhatinsights/platform-go-middlewares/request_id"
        log "github.com/sirupsen/logrus"
)

// MakeDevicesRouter adds support for operations on update
func MakeDevicesRouter(sub chi.Router) <span class="cov0" title="0">{
        sub.Get("/", GetInventory)
        sub.Route("/{DeviceUUID}", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(DeviceCtx)
                r.Get("/", GetDevice)
                r.Get("/updates", GetUpdateAvailableForDevice)
                r.Get("/image", GetDeviceImageInfo)
        }</span>)
}

type deviceContextKey int

// DeviceContextKey is the key to DeviceContext (for Device requests)
const DeviceContextKey deviceContextKey = iota

// DeviceContext implements context interfaces so we can shuttle around multiple values
type DeviceContext struct {
        DeviceUUID string
        // TODO: Implement devices by tag
        // Tag string
}

// DeviceCtx is a handler for Device requests
func DeviceCtx(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                var uCtx DeviceContext
                uCtx.DeviceUUID = chi.URLParam(r, "DeviceUUID")
                if uCtx.DeviceUUID == "" </span><span class="cov1" title="1">{
                        err := errors.NewBadRequest("DeviceUUID must be sent")
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                // TODO: Implement devices by tag
                // uCtx.Tag = chi.URLParam(r, "Tag")
                <span class="cov0" title="0">log.Debugf("UpdateCtx::uCtx: %#v", uCtx)
                ctx := context.WithValue(r.Context(), DeviceContextKey, uCtx)
                log.Debugf("UpdateCtx::ctx: %#v", ctx)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GetUpdateAvailableForDevice returns if exists update for the current image at the device.
func GetUpdateAvailableForDevice(w http.ResponseWriter, r *http.Request) <span class="cov10" title="2">{
        dc := r.Context().Value(DeviceContextKey).(DeviceContext)
        if dc.DeviceUUID == "" </span><span class="cov0" title="0">{
                return // Error set by DeviceCtx method
        }</span>
        <span class="cov10" title="2">contextServices, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        result, err := contextServices.DeviceService.GetUpdateAvailableForDeviceByUUID(dc.DeviceUUID)
        if err == nil </span><span class="cov0" title="0">{
                json.NewEncoder(w).Encode(result)
                return
        }</span>
        <span class="cov10" title="2">if _, ok := err.(*services.DeviceNotFoundError); ok </span><span class="cov1" title="1">{
                err := errors.NewNotFound("Could not find device")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">if _, ok := err.(*services.UpdateNotFoundError); ok </span><span class="cov0" title="0">{
                err := errors.NewNotFound("Could not find update")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">log.WithFields(log.Fields{
                "requestId": request_id.GetReqID(r.Context()),
        }).Error(err)
        apierr := errors.NewInternalServerError()
        w.WriteHeader(apierr.GetStatus())
        log.WithFields(log.Fields{
                "requestId":  request_id.GetReqID(r.Context()),
                "statusCode": apierr.GetStatus(),
        }).Error(apierr)
        json.NewEncoder(w).Encode(&amp;err)</span>
}

// GetDeviceImageInfo returns the information of a running image for a device
func GetDeviceImageInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        dc := r.Context().Value(DeviceContextKey).(DeviceContext)
        if dc.DeviceUUID == "" </span><span class="cov0" title="0">{
                return // Error set by DeviceCtx method
        }</span>
        <span class="cov0" title="0">contextServices, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        result, err := contextServices.DeviceService.GetDeviceImageInfo(dc.DeviceUUID)
        if err == nil </span><span class="cov0" title="0">{
                json.NewEncoder(w).Encode(result)
                return
        }</span>
        <span class="cov0" title="0">if _, ok := err.(*services.DeviceNotFoundError); ok </span><span class="cov0" title="0">{
                err := errors.NewNotFound("Could not find device")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">log.WithFields(log.Fields{
                "requestId": request_id.GetReqID(r.Context()),
        }).Error(err)
        apierr := errors.NewInternalServerError()
        w.WriteHeader(apierr.GetStatus())
        log.WithFields(log.Fields{
                "requestId":  request_id.GetReqID(r.Context()),
                "statusCode": apierr.GetStatus(),
        }).Error(apierr)
        json.NewEncoder(w).Encode(&amp;err)</span>
}

// GetDevice returns all available information that edge api has about a device
// It returns the information stored on our database and the device ID on our side, if any.
// Returns the information of a running image and previous image in case of a rollback.
// Returns updates available to a device.
// Returns updates transactions for that device, if any.
func GetDevice(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        dc := r.Context().Value(DeviceContextKey).(DeviceContext)
        if dc.DeviceUUID == "" </span><span class="cov0" title="0">{
                return // Error set by DeviceCtx method
        }</span>
        <span class="cov0" title="0">contextServices, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        result, err := contextServices.DeviceService.GetDeviceDetails(dc.DeviceUUID)
        if err == nil </span><span class="cov0" title="0">{
                json.NewEncoder(w).Encode(result)
                return
        }</span>
        <span class="cov0" title="0">if _, ok := err.(*services.DeviceNotFoundError); ok </span><span class="cov0" title="0">{
                err := errors.NewNotFound("Could not find device")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">log.WithFields(log.Fields{
                "requestId": request_id.GetReqID(r.Context()),
        }).Error(err)
        apierr := errors.NewInternalServerError()
        w.WriteHeader(apierr.GetStatus())
        log.WithFields(log.Fields{
                "requestId":  request_id.GetReqID(r.Context()),
                "statusCode": apierr.GetStatus(),
        }).Error(apierr)
        json.NewEncoder(w).Encode(&amp;err)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package routes

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/go-chi/chi"
        "github.com/redhatinsights/edge-api/pkg/clients/imagebuilder"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/models"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
        "github.com/redhatinsights/edge-api/pkg/services"
        log "github.com/sirupsen/logrus"
)

// This provides type safety in the context object for our "image" key.  We
// _could_ use a string but we shouldn't just in case someone else decides that
// "image" would make the perfect key in the context object.  See the
// documentation: https://golang.org/pkg/context/#WithValue for further
// rationale.
type imageTypeKey int

const imageKey imageTypeKey = iota

// MakeImagesRouter adds support for operations on images
func MakeImagesRouter(sub chi.Router) <span class="cov0" title="0">{
        sub.With(validateGetAllImagesSearchParams).With(common.Paginate).Get("/", GetAllImages)
        sub.Post("/", CreateImage)
        sub.Post("/checkImageName", CheckImageName)
        sub.Route("/{ostreeCommitHash}/info", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(ImageByOSTreeHashCtx)  // TODO: Consistent logging
                r.Get("/", GetImageByOstree) // TODO: Consistent logging
        }</span>)
        <span class="cov0" title="0">sub.Route("/{imageId}", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(ImageByIDCtx)                           // TODO: Consistent logging
                r.Get("/", GetImageByID)                      // TODO: Consistent logging
                r.Get("/status", GetImageStatusByID)          // TODO: Consistent logging
                r.Get("/repo", GetRepoForImage)               // TODO: Consistent logging
                r.Get("/metadata", GetMetadataForImage)       // TODO: Consistent logging
                r.Post("/installer", CreateInstallerForImage) // TODO: Consistent logging
                r.Post("/kickstart", CreateKickStartForImage) // TODO: Consistent logging
                r.Post("/update", CreateImageUpdate)          // TODO: Consistent logging
                r.Post("/retry", RetryCreateImage)            // TODO: Consistent logging
        }</span>)
}

var validStatuses = []string{models.ImageStatusCreated, models.ImageStatusBuilding, models.ImageStatusError, models.ImageStatusSuccess}

// ImageByOSTreeHashCtx is a handler for Images but adds finding images by Ostree Hash
func ImageByOSTreeHashCtx(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                s, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                if commitHash := chi.URLParam(r, "ostreeCommitHash"); commitHash != "" </span><span class="cov0" title="0">{
                        image, err := s.ImageService.GetImageByOSTreeCommitHash(commitHash)
                        if err != nil </span><span class="cov0" title="0">{
                                var responseErr errors.APIError
                                switch err.(type) </span>{
                                case *services.ImageNotFoundError:<span class="cov0" title="0">
                                        responseErr = errors.NewNotFound(err.Error())</span>
                                case *services.AccountNotSet:<span class="cov0" title="0">
                                        responseErr = errors.NewBadRequest(err.Error())</span>
                                default:<span class="cov0" title="0">
                                        responseErr = errors.NewInternalServerError()</span>
                                }
                                <span class="cov0" title="0">w.WriteHeader(responseErr.GetStatus())
                                json.NewEncoder(w).Encode(&amp;responseErr)
                                return</span>
                        }
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), imageKey, image)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                } else<span class="cov0" title="0"> {
                        err := errors.NewBadRequest("OSTreeCommitHash required")
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
        })

}

// ImageByIDCtx is a handler for Image requests
func ImageByIDCtx(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                s, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                if imageID := chi.URLParam(r, "imageId"); imageID != "" </span><span class="cov0" title="0">{
                        image, err := s.ImageService.GetImageByID(imageID)
                        if err != nil </span><span class="cov0" title="0">{
                                var responseErr errors.APIError
                                switch err.(type) </span>{
                                case *services.ImageNotFoundError:<span class="cov0" title="0">
                                        responseErr = errors.NewNotFound(err.Error())</span>
                                case *services.AccountNotSet:<span class="cov0" title="0">
                                        responseErr = errors.NewBadRequest(err.Error())</span>
                                case *services.IDMustBeInteger:<span class="cov0" title="0">
                                        responseErr = errors.NewBadRequest(err.Error())</span>
                                default:<span class="cov0" title="0">
                                        responseErr = errors.NewInternalServerError()</span>
                                }
                                <span class="cov0" title="0">w.WriteHeader(responseErr.GetStatus())
                                json.NewEncoder(w).Encode(&amp;responseErr)
                                return</span>
                        }
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), imageKey, image)

                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                } else<span class="cov0" title="0"> {
                        err := errors.NewBadRequest("Image ID required")
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
        })
}

// A CreateImageRequest model.
type CreateImageRequest struct {
        // The image to create.
        //
        // in: body
        // required: true
        Image *models.Image
}

// CreateImage creates an image on hosted image builder.
// It always creates a commit on Image Builder.
// Then we create our repo with the ostree commit and if needed, create the installer.
func CreateImage(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()
        image, err := initImageCreateRequest(w, r)
        if err != nil </span><span class="cov4" title="2">{
                // initImageCreateRequest() already writes the response
                return
        }</span>
        <span class="cov1" title="1">account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">services.Log.Debug("Creating image")
        err = services.ImageService.CreateImage(image, account)
        if err != nil </span><span class="cov0" title="0">{
                services.Log.Error(err)
                err := errors.NewInternalServerError()
                err.SetTitle("Failed creating image")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">services.Log.WithFields(log.Fields{
                "imageId": image.ID,
        }).Info("Image created")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(&amp;image)</span>

}

// CreateImageUpdate creates an update for an exitent image on hosted image builder.
func CreateImageUpdate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()
        image, err := initImageCreateRequest(w, r)
        if err != nil </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{
                        "error":   err.Error(),
                        "imageID": image.ID,
                }).Debug("Error parsing json")
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">ctx := r.Context()
        previousImage, ok := ctx.Value(imageKey).(*models.Image)
        if !ok </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Must pass image id")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>
        <span class="cov0" title="0">account, err := common.GetAccount(r)
        if err != nil || previousImage.Account != account </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{
                        "error":   err.Error(),
                        "account": account,
                        "imageID": image.ID,
                }).Error("Error retrieving account")
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>

        <span class="cov0" title="0">err = services.ImageService.UpdateImage(image, previousImage)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                err := errors.NewInternalServerError()
                err.SetTitle("Failed creating image")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(&amp;image)</span>

}

// initImageCreateRequest validates request to create/update an image.
func initImageCreateRequest(w http.ResponseWriter, r *http.Request) (*models.Image, error) <span class="cov6" title="3">{
        var image *models.Image
        if err := json.NewDecoder(r.Body).Decode(&amp;image); err != nil </span><span class="cov1" title="1">{
                log.Error(err)
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return nil, err
        }</span>
        <span class="cov4" title="2">if err := image.ValidateRequest(); err != nil </span><span class="cov1" title="1">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return nil, err
        }</span>
        <span class="cov1" title="1">return image, nil</span>
}

var imageFilters = common.ComposeFilters(
        common.OneOfFilterHandler(&amp;common.Filter{
                QueryParam: "status",
                DBField:    "images.status",
        }),
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "name",
                DBField:    "images.name",
        }),
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "distribution",
                DBField:    "images.distribution",
        }),
        common.CreatedAtFilterHandler(&amp;common.Filter{
                QueryParam: "created_at",
                DBField:    "images.created_at",
        }),
        common.SortFilterHandler("images", "created_at", "DESC"),
)

type validationError struct {
        Key    string
        Reason string
}

func validateGetAllImagesSearchParams(next http.Handler) http.Handler <span class="cov7" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="4">{
                errs := []validationError{}
                if statuses, ok := r.URL.Query()["status"]; ok </span><span class="cov4" title="2">{
                        for _, status := range statuses </span><span class="cov6" title="3">{
                                if status != models.ImageStatusCreated &amp;&amp; status != models.ImageStatusBuilding &amp;&amp; status != models.ImageStatusError &amp;&amp; status != models.ImageStatusSuccess </span><span class="cov4" title="2">{
                                        errs = append(errs, validationError{Key: "status", Reason: fmt.Sprintf("%s is not a valid status. Status must be %s", status, strings.Join(validStatuses, " or "))})
                                }</span>
                        }
                }
                <span class="cov7" title="4">if val := r.URL.Query().Get("created_at"); val != "" </span><span class="cov1" title="1">{
                        if _, err := time.Parse(common.LayoutISO, val); err != nil </span><span class="cov1" title="1">{
                                errs = append(errs, validationError{Key: "created_at", Reason: err.Error()})
                        }</span>
                }
                <span class="cov7" title="4">if val := r.URL.Query().Get("sort_by"); val != "" </span><span class="cov4" title="2">{
                        name := val
                        if string(val[0]) == "-" </span><span class="cov0" title="0">{
                                name = val[1:]
                        }</span>
                        <span class="cov4" title="2">if name != "status" &amp;&amp; name != "name" &amp;&amp; name != "distribution" &amp;&amp; name != "created_at" </span><span class="cov4" title="2">{
                                errs = append(errs, validationError{Key: "sort_by", Reason: fmt.Sprintf("%s is not a valid sort_by. Sort-by must be status or name or distribution or created_at", name)})
                        }</span>
                }

                <span class="cov7" title="4">if len(errs) == 0 </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov7" title="4">w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(&amp;errs)</span>
        })
}

// GetAllImages image objects from the database for an account
func GetAllImages(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        services.Log.Debug("Getting all images")
        var count int64
        var images []models.Image
        result := imageFilters(r, db.DB)
        pagination := common.GetPagination(r)
        account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                services.Log.WithField("error", err).Debug("Account not found")
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">countResult := imageFilters(r, db.DB.Model(&amp;models.Image{})).Where("images.account = ?", account).Count(&amp;count)
        if countResult.Error != nil </span><span class="cov0" title="0">{
                services.Log.WithField("error", countResult.Error.Error()).Error("Error retrieving images")
                countErr := errors.NewInternalServerError()
                w.WriteHeader(countErr.GetStatus())
                json.NewEncoder(w).Encode(&amp;countErr)
                return
        }</span>
        <span class="cov0" title="0">result = result.Limit(pagination.Limit).Offset(pagination.Offset).Preload("Packages").Preload("Commit.Repo").Where("images.account = ?", account).Joins("Commit").Joins("Installer").Find(&amp;images)
        if result.Error != nil </span><span class="cov0" title="0">{
                services.Log.WithField("error", result.Error.Error()).Error("Error retrieving images")
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{"data": &amp;images, "count": count})</span>
}

func getImage(w http.ResponseWriter, r *http.Request) *models.Image <span class="cov10" title="6">{
        ctx := r.Context()
        image, ok := ctx.Value(imageKey).(*models.Image)
        if !ok </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Must pass image identifier")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return nil
        }</span>
        <span class="cov10" title="6">return image</span>
}

// GetImageStatusByID returns the image status.
func GetImageStatusByID(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if image := getImage(w, r); image != nil </span><span class="cov1" title="1">{
                json.NewEncoder(w).Encode(struct {
                        Status string
                        Name   string
                        ID     uint
                }{
                        image.Status,
                        image.Name,
                        image.ID,
                })
        }</span>
}

//ImageDetail return the structure to inform package info to images
type ImageDetail struct {
        Image              *models.Image `json:"image"`
        AdditionalPackages int           `json:"additional_packages"`
        Packages           int           `json:"packages"`
        UpdateAdded        int           `json:"update_added"`
        UpdateRemoved      int           `json:"update_removed"`
        UpdateUpdated      int           `json:"update_updated"`
}

// GetImageByID obtains a image from the database for an account
func GetImageByID(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if image := getImage(w, r); image != nil </span><span class="cov1" title="1">{
                services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)

                var imgDetail ImageDetail
                imgDetail.Image = image
                imgDetail.Packages = len(image.Commit.InstalledPackages)
                imgDetail.AdditionalPackages = len(image.Packages)

                upd, err := services.ImageService.GetUpdateInfo(*image)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error getting update info: %v", err)
                }</span>
                <span class="cov1" title="1">if upd != nil </span><span class="cov0" title="0">{
                        imgDetail.UpdateAdded = len(upd[len(upd)-1].PackageDiff.Removed)
                        imgDetail.UpdateRemoved = len(upd[len(upd)-1].PackageDiff.Added)
                        imgDetail.UpdateUpdated = len(upd[len(upd)-1].PackageDiff.Upgraded)
                }</span> else<span class="cov1" title="1"> {
                        imgDetail.UpdateAdded = 0
                        imgDetail.UpdateRemoved = 0
                        imgDetail.UpdateUpdated = 0
                }</span>
                <span class="cov1" title="1">json.NewEncoder(w).Encode(imgDetail)</span>
        }
}

// GetImageByOstree obtains a image from the database for an account based on Commit Ostree
func GetImageByOstree(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if image := getImage(w, r); image != nil </span><span class="cov1" title="1">{
                json.NewEncoder(w).Encode(&amp;image)
        }</span>
}

// CreateInstallerForImage creates a installer for a Image
// It requires a created image and an update for the commit
func CreateInstallerForImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        image := getImage(w, r)
        var imageInstaller *models.Installer
        if err := json.NewDecoder(r.Body).Decode(&amp;imageInstaller); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">image.ImageType = models.ImageTypeInstaller
        image.Installer = imageInstaller

        tx := db.DB.Save(&amp;image)
        if tx.Error != nil </span><span class="cov0" title="0">{
                log.Fatal(tx.Error)
                err := errors.NewInternalServerError()
                err.SetTitle("Failed saving image status")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">client := imagebuilder.InitClient(r.Context(), services.Log)
        image, err := client.ComposeInstaller(image)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>

        <span class="cov0" title="0">go func(id uint, ctx context.Context) </span><span class="cov0" title="0">{

                services, _ := ctx.Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                var i *models.Image
                db.DB.Joins("Commit").Joins("Installer").First(&amp;i, id)
                for </span><span class="cov0" title="0">{
                        i, err := services.ImageService.UpdateImageStatus(i)
                        if err != nil </span><span class="cov0" title="0">{
                                services.ImageService.SetErrorStatusOnImage(err, i)
                        }</span>
                        <span class="cov0" title="0">if i.Installer.Status != models.ImageStatusBuilding </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">time.Sleep(1 * time.Minute)</span>
                }
                <span class="cov0" title="0">if i.Installer.Status == models.ImageStatusSuccess </span><span class="cov0" title="0">{
                        err = services.ImageService.AddUserInfo(image)
                        if err != nil </span><span class="cov0" title="0">{
                                // TODO: Temporary. Handle error better.
                                log.Errorf("Kickstart file injection failed %s", err.Error())
                        }</span>
                }
        }(image.ID, r.Context())

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(&amp;image)</span>
}

// CreateRepoForImage creates a repo for a Image
func CreateRepoForImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        image := getImage(w, r)

        go func(id uint, ctx context.Context) </span><span class="cov0" title="0">{
                services, _ := ctx.Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                var i *models.Image
                db.DB.Joins("Commit").Joins("Installer").First(&amp;i, id)
                db.DB.First(&amp;i.Commit, i.CommitID)
                services.ImageService.CreateRepoForImage(i)
        }</span>(image.ID, r.Context())

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}

//GetRepoForImage gets the repository for a Image
func GetRepoForImage(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        if image := getImage(w, r); image != nil </span><span class="cov4" title="2">{
                services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                repo, err := services.RepoService.GetRepoByID(image.Commit.RepoID)
                if err != nil </span><span class="cov1" title="1">{
                        err := errors.NewNotFound(fmt.Sprintf("Commit repo wasn't found in the database: #%v", image.CommitID))
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov1" title="1">json.NewEncoder(w).Encode(repo)</span>
        }
}

//GetMetadataForImage gets the metadata from image-builder on /metadata endpoint
func GetMetadataForImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        client := imagebuilder.InitClient(r.Context(), services.Log)
        if image := getImage(w, r); image != nil </span><span class="cov0" title="0">{
                meta, err := client.GetMetadata(image)
                if err != nil </span><span class="cov0" title="0">{
                        err := errors.NewInternalServerError()
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">json.NewEncoder(w).Encode(meta)</span>
        }
}

// CreateKickStartForImage creates a kickstart file for an existent image
func CreateKickStartForImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if image := getImage(w, r); image != nil </span><span class="cov0" title="0">{
                services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                err := services.ImageService.AddUserInfo(image)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO: Temporary. Handle error better.
                        log.Errorf("Kickstart file injection failed %s", err.Error())
                        err := errors.NewInternalServerError()
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
        }
}

// CheckImageNameResponse indicates whether or not the image exists
type CheckImageNameResponse struct {
        ImageExists bool `json:"ImageExists"`
}

// CheckImageName verifies that ImageName exists
func CheckImageName(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        services.Log.Debug("Checking image name")
        var image *models.Image
        if err := json.NewDecoder(r.Body).Decode(&amp;image); err != nil </span><span class="cov0" title="0">{
                services.Log.WithField("error", err.Error()).Debug("Bad request")
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>
        <span class="cov4" title="2">account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                services.Log.WithField("error", err.Error()).Debug("Bad request")
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov4" title="2">if image == nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                services.Log.WithField("error", err.Error()).Error("Internal Server Error")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>
        <span class="cov4" title="2">imageExists, err := services.ImageService.CheckImageName(image.Name, account)
        if err != nil </span><span class="cov0" title="0">{
                services.Log.WithField("error", err.Error()).Error("Internal Server Error")
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov4" title="2">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(CheckImageNameResponse{
                ImageExists: imageExists,
        })</span>
}

// RetryCreateImage retries the image creation
func RetryCreateImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if image := getImage(w, r); image != nil </span><span class="cov0" title="0">{
                services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                err := services.ImageService.RetryCreateImage(image)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err)
                        err := errors.NewInternalServerError()
                        err.SetTitle("Failed creating image")
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
                json.NewEncoder(w).Encode(&amp;image)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package routes

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "gorm.io/gorm"

        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/models"
        log "github.com/sirupsen/logrus"

        "github.com/go-chi/chi"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
)

type imageSetTypeKey int

const imageSetKey imageSetTypeKey = iota

var sortOption = []string{"created_at", "updated_at", "name", "status"}
var statusOption = []string{models.ImageStatusCreated, models.ImageStatusBuilding, models.ImageStatusError, models.ImageStatusSuccess}

// MakeImageSetsRouter adds support for operations on image-sets
func MakeImageSetsRouter(sub chi.Router) <span class="cov0" title="0">{
        sub.With(validateFilterParams).With(common.Paginate).Get("/", ListAllImageSets) // TODO: Consistent logging
        sub.Route("/{imageSetId}", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(ImageSetCtx)                                                            // TODO: Consistent logging
                r.With(validateFilterParams).With(common.Paginate).Get("/", GetImageSetsByID) // TODO: Consistent logging
        }</span>)
}

var imageSetFilters = common.ComposeFilters(

        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "status",
                DBField:    "images.status",
        }),
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "name",
                DBField:    "image_sets.name",
        }),
        common.SortFilterHandler("image_sets", "created_at", "DESC"),
)

var imageDetailFilters = common.ComposeFilters(
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "status",
                DBField:    "images.status",
        }),

        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "name",
                DBField:    "images.name",
        }),
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "version",
                DBField:    "images.version",
        }),
        common.SortFilterHandler("images", "updated_at", "DESC"),
)

var imageStatusFilters = common.ComposeFilters(
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "status",
                DBField:    "images.status",
        }),
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "name",
                DBField:    "image_sets.name",
        }),
        common.SortFilterHandler("images", "created_at", "DESC"),
)

// ImageSetCtx provides the handler for Image Sets
func ImageSetCtx(next http.Handler) http.Handler <span class="cov0" title="0">{

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var imageSet models.ImageSet
                account, err := common.GetAccount(r)
                if err != nil </span><span class="cov0" title="0">{
                        log.Info(err)
                        err := errors.NewBadRequest(err.Error())
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">if imageSetID := chi.URLParam(r, "imageSetId"); imageSetID != "" </span><span class="cov0" title="0">{
                        _, err := strconv.Atoi(imageSetID)
                        if err != nil </span><span class="cov0" title="0">{
                                err := errors.NewBadRequest(err.Error())
                                w.WriteHeader(err.GetStatus())
                                json.NewEncoder(w).Encode(&amp;err)
                                return
                        }</span>
                        <span class="cov0" title="0">result := db.DB.Where("account = ? and Image_sets.id = ?", account, imageSetID).Find(&amp;imageSet)

                        if result.Error != nil </span><span class="cov0" title="0">{
                                err := errors.NewNotFound(result.Error.Error())
                                w.WriteHeader(err.GetStatus())
                                json.NewEncoder(w).Encode(&amp;err)
                                return
                        }</span>
                        <span class="cov0" title="0">if imageSet.Images != nil </span><span class="cov0" title="0">{
                                db.DB.Where("image_set_id = ?", imageSetID).Find(&amp;imageSet.Images)
                                db.DB.Where("id = ?", &amp;imageSet.Images[len(imageSet.Images)-1].InstallerID).Find(&amp;imageSet.Images[len(imageSet.Images)-1].Installer)
                        }</span>
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), imageSetKey, &amp;imageSet)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                }
        })
}

//ImageSetInstallerURL returns Imageset structure with last installer available
type ImageSetInstallerURL struct {
        ImageSetData     models.ImageSet `json:"image_set"`
        ImageBuildISOURL *string         `json:"image_build_iso_url"`
}

// ListAllImageSets return the list of image sets and images
func ListAllImageSets(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var imageSet []models.ImageSet
        var imageSetInfo []ImageSetInstallerURL
        var count int64
        var result *gorm.DB
        pagination := common.GetPagination(r)
        account, err := common.GetAccount(r)

        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>

        <span class="cov1" title="1">countResult := imageSetFilters(r, db.DB.Model(&amp;models.ImageSet{})).Joins(`JOIN Images ON Image_Sets.id = Images.image_set_id AND Images.id = (Select Max(id) from Images where Images.image_set_id = Image_Sets.id)`).Where(`Image_Sets.account = ? `, account).Count(&amp;count)
        if countResult.Error != nil </span><span class="cov0" title="0">{
                countErr := errors.NewInternalServerError()
                log.Error(countErr)
                w.WriteHeader(countErr.GetStatus())
                json.NewEncoder(w).Encode(&amp;countErr)
                return
        }</span>
        <span class="cov1" title="1">log.Debugf("r.URL.Query() %v \n", r.URL.Query().Get("sort_by"))
        if r.URL.Query().Get("sort_by") != "status" &amp;&amp; r.URL.Query().Get("sort_by") != "-status" </span><span class="cov1" title="1">{
                result = imageSetFilters(r, db.DB.Model(&amp;models.ImageSet{})).Limit(pagination.Limit).Offset(pagination.Offset).Preload("Images").Joins(`JOIN Images ON Image_Sets.id = Images.image_set_id AND Images.id = (Select Max(id) from Images where Images.image_set_id = Image_Sets.id)`).Where(`Image_Sets.account = ? `, account).Find(&amp;imageSet)
        }</span> else<span class="cov0" title="0"> {
                result = imageStatusFilters(r, db.DB.Model(&amp;models.ImageSet{})).Limit(pagination.Limit).Offset(pagination.Offset).Preload("Images").Joins(`JOIN Images ON Image_Sets.id = Images.image_set_id AND Images.id = (Select Max(id) from Images where Images.image_set_id = Image_Sets.id)`).Where(`Image_Sets.account = ? `, account).Find(&amp;imageSet)
        }</span>

        <span class="cov1" title="1">for _, img := range imageSet </span><span class="cov0" title="0">{
                var imgSet ImageSetInstallerURL
                imgSet.ImageSetData = img
                if img.Images != nil &amp;&amp; img.Images[len(img.Images)-1].InstallerID != nil </span><span class="cov0" title="0">{
                        result = db.DB.First(&amp;img.Images[len(img.Images)-1].Installer, img.Images[len(img.Images)-1].InstallerID)
                        imgSet.ImageBuildISOURL = &amp;img.Images[len(img.Images)-1].Installer.ImageBuildISOURL
                }</span>

                <span class="cov0" title="0">imageSetInfo = append(imageSetInfo, imgSet)</span>
        }
        <span class="cov1" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Not Found")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>

        <span class="cov1" title="1">var response common.EdgeAPIPaginatedResponse
        response.Count = count
        response.Data = imageSetInfo
        json.NewEncoder(w).Encode(response)</span>
}

//ImageSetImagePackages return info related to details on images from imageset
type ImageSetImagePackages struct {
        ImageSetData     models.ImageSet `json:"image_set"`
        Images           []ImageDetail   `json:"images"`
        ImageBuildISOURL string          `json:"image_build_iso_url"`
}

// GetImageSetsByID returns the list of Image Sets by a given Image Set ID
func GetImageSetsByID(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        // var imageSetData models.ImageSet
        var images []models.Image
        var details ImageSetImagePackages
        var response common.EdgeAPIPaginatedResponse
        pagination := common.GetPagination(r)
        account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">ctx := r.Context()
        imageSet, ok := ctx.Value(imageSetKey).(*models.ImageSet)
        if !ok </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Must pass image set id")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>
        <span class="cov1" title="1">result := imageDetailFilters(r, db.DB.Model(&amp;models.Image{})).Limit(pagination.Limit).Offset(pagination.Offset).
                Preload("Commit.Repo").Preload("Commit.InstalledPackages").Preload("Installer").
                Joins(`JOIN Image_Sets ON Image_Sets.id = Images.image_set_id`).
                Where(`Image_Sets.account = ? and  Image_sets.id = ?`, account, &amp;imageSet.ID).Find(&amp;images)

        if result.Error != nil </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Error to filter images")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>

        <span class="cov1" title="1">s, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        Imgs := returnImageDetails(images, s)

        details.ImageSetData = *imageSet
        details.Images = Imgs

        if Imgs != nil &amp;&amp; Imgs[len(Imgs)-1].Image != nil &amp;&amp; Imgs[len(Imgs)-1].Image.InstallerID != nil </span><span class="cov0" title="0">{
                img := Imgs[len(Imgs)-1].Image
                details.ImageBuildISOURL = img.Installer.ImageBuildISOURL
        }</span>

        <span class="cov1" title="1">response.Data = &amp;details
        response.Count = int64(len(images))
        json.NewEncoder(w).Encode(response)</span>
}

func validateFilterParams(next http.Handler) http.Handler <span class="cov5" title="6">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="6">{

                errs := []common.ValidationError{}
                if statuses, ok := r.URL.Query()["status"]; ok </span><span class="cov4" title="4">{
                        for _, status := range statuses </span><span class="cov4" title="4">{
                                if !contains(statusOption, strings.ToUpper(status)) </span><span class="cov4" title="4">{
                                        errs = append(errs, common.ValidationError{Key: "status", Reason: fmt.Sprintf("%s is not a valid status. Status must be %s", status, strings.Join(validStatuses, " or "))})
                                }</span>
                        }
                }
                <span class="cov5" title="6">if val := r.URL.Query().Get("sort_by"); val != "" </span><span class="cov4" title="4">{
                        name := val
                        if string(val[0]) == "-" </span><span class="cov0" title="0">{
                                name = val[1:]
                        }</span>
                        <span class="cov4" title="4">if !contains(sortOption, name) </span><span class="cov4" title="4">{
                                errs = append(errs, common.ValidationError{Key: "sort_by", Reason: fmt.Sprintf("%s is not a valid sort_by. Sort-by must %v", name, strings.Join(sortOption, " or "))})
                        }</span>
                }

                <span class="cov5" title="6">if len(errs) == 0 </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov5" title="6">w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(&amp;errs)</span>
        })
}

func contains(s []string, searchterm string) bool <span class="cov6" title="8">{
        for _, a := range s </span><span class="cov10" title="32">{
                if a == searchterm </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov6" title="8">return false</span>
}

func returnImageDetails(images []models.Image, s *dependencies.EdgeAPIServices) []ImageDetail <span class="cov1" title="1">{
        var Imgs []ImageDetail

        for idx, i := range images </span><span class="cov0" title="0">{
                err := db.DB.Model(i).Association("Packages").Find(&amp;images[idx].Packages)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">img, err := s.ImageService.AddPackageInfo(&amp;images[idx])

                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Image detail not found \n")
                }</span>
                <span class="cov0" title="0">Imgs = append(Imgs, ImageDetail(img))</span>
        }

        <span class="cov1" title="1">return Imgs</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package routes

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/go-chi/chi"
        "github.com/redhatinsights/edge-api/pkg/clients/inventory"
        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/services"
)

// MakeInventoryRouter adds support for operations on inventory
func MakeInventoryRouter(sub chi.Router) <span class="cov0" title="0">{
        sub.Get("/", GetInventory)
}</span>

// InventoryData represents the structure of inventory response
type InventoryData struct {
        Total   int
        Count   int
        Page    int
        PerPage int
        Results []InventoryResponse
}

// InventoryResponse represents the structure of inventory data on response
type InventoryResponse struct {
        ID         string
        DeviceName string
        LastSeen   string
        ImageInfo  *services.ImageInfo
}

// GetInventory make the call to inventory api and inject edge info
func GetInventory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var param *inventory.Params = new(inventory.Params)

        param.PerPage = r.URL.Query().Get("per_page")
        param.Page = r.URL.Query().Get("page")
        param.OrderBy = r.URL.Query().Get("order_by")
        param.OrderHow = r.URL.Query().Get("order_how")
        param.HostnameOrID = r.URL.Query().Get("hostname_or_id")
        param.DeviceStatus = r.URL.Query().Get("device_status")

        client := inventory.InitClient(r.Context())

        var InventoryData InventoryData
        var results []InventoryResponse

        inventory, err := client.ReturnDevices(param)
        if err != nil || inventory.Count == 0 </span><span class="cov0" title="0">{
                err := errors.NewNotFound("No devices found")
                w.WriteHeader(err.GetStatus())

        }</span>
        <span class="cov0" title="0">fmt.Printf(":: inventory :: %v\n", inventory)
        results = GetUpdateAvailableInfo(param, r, inventory)

        fmt.Printf(":: inventory :: %v\n", results)
        InventoryData.Count = inventory.Count
        InventoryData.Total = inventory.Total
        InventoryData.Results = results

        json.NewEncoder(w).Encode(InventoryData)</span>
}

// GetUpdateAvailableInfo returns the image information
func GetUpdateAvailableInfo(param *inventory.Params, r *http.Request, inventoryResp inventory.Response) (IvtResponse []InventoryResponse) <span class="cov0" title="0">{
        var ivt []InventoryResponse
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        deviceService := services.DeviceService

        for _, device := range inventoryResp.Result </span><span class="cov0" title="0">{
                var i InventoryResponse
                imageInfo, err := deviceService.GetDeviceImageInfo(device.ID)
                i.ID = device.ID
                i.DeviceName = device.DisplayName
                i.LastSeen = device.LastSeen

                if err != nil </span><span class="cov0" title="0">{
                        i.ImageInfo = nil

                }</span> else<span class="cov0" title="0"> if imageInfo != nil </span><span class="cov0" title="0">{
                        i.ImageInfo = imageInfo
                }</span>
                <span class="cov0" title="0">if param != nil &amp;&amp; param.DeviceStatus == "update_available" &amp;&amp; imageInfo.UpdatesAvailable != nil </span><span class="cov0" title="0">{
                        ivt = append(ivt, i)
                }</span> else<span class="cov0" title="0"> if param != nil &amp;&amp; param.DeviceStatus == "running" &amp;&amp; imageInfo.UpdatesAvailable == nil </span><span class="cov0" title="0">{
                        ivt = append(ivt, i)
                }</span> else<span class="cov0" title="0"> if param != nil &amp;&amp; param.DeviceStatus == "" </span><span class="cov0" title="0">{
                        ivt = append(ivt, i)
                }</span> else<span class="cov0" title="0"> {
                        ivt = append(ivt, i)
                }</span>
        }
        <span class="cov0" title="0">return ivt</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package routes

import "net/http"

// StatusOK returns a simple 200 status code
func StatusOK(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        w.WriteHeader(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package routes

import (
        "encoding/json"
        "io/ioutil"
        "net/http"
        "strconv"

        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/errors"

        "github.com/go-chi/chi"
)

// MakeFDORouter creates a router for the FDO API
func MakeFDORouter(sub chi.Router) <span class="cov2" title="2">{
        sub.Route("/ownership_voucher", func(r chi.Router) </span><span class="cov2" title="2">{
                r.Use(validateMiddleware)                  // TODO: Consistent logging
                r.Post("/", CreateOwnershipVouchers)       // TODO: Consistent logging
                r.Post("/delete", DeleteOwnershipVouchers) // TODO: Consistent logging
                r.Post("/parse", ParseOwnershipVouchers)   // TODO: Consistent logging
                r.Post("/connect", ConnectDevices)         // TODO: Consistent logging
        }</span>)
}

// CreateOwnershipVouchers creates empty devices for the given ownership vouchers
func CreateOwnershipVouchers(w http.ResponseWriter, r *http.Request) <span class="cov6" title="6">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()

        validationErr := validateUploadRequestHeaders(r)
        if validationErr != nil </span><span class="cov4" title="3">{
                services.Log.Error("Couldn't validate ownership voucher upload request headers ", validationErr.Error())
                badRequestResponseBuilder(w, validationErr, "invalid_header")
                return
        }</span>

        <span class="cov4" title="3">data, _ := ioutil.ReadAll(r.Body)

        numOfOVs := r.Header.Get("X-Number-Of-Vouchers")
        numOfOVsInt, _ := strconv.Atoi(numOfOVs) // checking for the error is done in the validation function

        resp, err := services.OwnershipVoucherService.BatchUploadOwnershipVouchers(data, uint(numOfOVsInt))
        if err != nil </span><span class="cov2" title="2">{
                switch err.Error() </span>{
                case "bad request":<span class="cov0" title="0">
                        services.Log.Error("Couldn't upload ownership vouchers ", err.Error())
                        w.WriteHeader(errors.NewBadRequest(err.Error()).GetStatus())
                        json.NewEncoder(w).Encode(resp)
                        return</span>
                default:<span class="cov2" title="2">
                        services.Log.Error(err.Error())
                        badRequestResponseBuilder(w, errors.NewBadRequest(err.Error()), "fdo_client")
                        return</span>
                }
        }
        <span class="cov1" title="1">w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(resp)</span>
}

// DeleteOwnershipVouchers deletes devices for the given ownership vouchers GUIDs
func DeleteOwnershipVouchers(w http.ResponseWriter, r *http.Request) <span class="cov4" title="4">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()

        validationErr := validateContentTypeJSONHeader(r)
        if validationErr != nil </span><span class="cov1" title="1">{
                services.Log.Error("Couldn't validate ownership voucher delete request headers ", validationErr.Error())
                badRequestResponseBuilder(w, validationErr, "invalid_header")
                return
        }</span>

        <span class="cov4" title="3">dataBytes, _ := ioutil.ReadAll(r.Body)
        data := []string{}
        err := json.Unmarshal(dataBytes, &amp;data)
        if err != nil </span><span class="cov1" title="1">{ // can't unmarshal json
                badRequestResponseBuilder(w, errors.NewBadRequest(err.Error()), "incomplete_body")
                return
        }</span>

        <span class="cov2" title="2">resp, err := services.OwnershipVoucherService.BatchDeleteOwnershipVouchers(data)
        if err != nil </span><span class="cov1" title="1">{
                switch err.Error() </span>{
                case "bad request":<span class="cov0" title="0">
                        services.Log.Error("Couldn't delete ownership vouchers ", err.Error())
                        w.WriteHeader(errors.NewBadRequest(err.Error()).GetStatus())
                        json.NewEncoder(w).Encode(resp)
                        return</span>
                default:<span class="cov1" title="1">
                        services.Log.Error(err.Error())
                        badRequestResponseBuilder(w, errors.NewBadRequest(err.Error()), "fdo_client")
                        return</span>
                }
        }
        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(resp)</span>
}

// ParseOwnershipVouchers parses ownership vouchers from the given cbor binary data
func ParseOwnershipVouchers(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()

        if r.Header.Get("Content-Type") != "application/cbor" </span><span class="cov1" title="1">{
                badRequestResponseBuilder(w, errors.NewBadRequest("Content-Type header must be application/cbor"), "invalid_header")
                return
        }</span>
        <span class="cov1" title="1">data, _ := ioutil.ReadAll(r.Body)

        resp, err := services.OwnershipVoucherService.ParseOwnershipVouchers(data)
        if err != nil </span><span class="cov0" title="0">{
                services.Log.Error("Couldn't parse ownership vouchers ", err.Error())
                badRequestResponseBuilder(w, errors.NewBadRequest(err.Error()), "validation_parse_error")
                return
        }</span>
        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(resp)</span>
}

// ConnectDevices connects devices to the given ownership vouchers
func ConnectDevices(w http.ResponseWriter, r *http.Request) <span class="cov4" title="3">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()

        validationErr := validateContentTypeJSONHeader(r)
        if validationErr != nil </span><span class="cov1" title="1">{
                services.Log.Error("Couldn't validate connect request headers ", validationErr.Error())
                badRequestResponseBuilder(w, validationErr, "invalid_header")
                return
        }</span>

        <span class="cov2" title="2">dataBytes, _ := ioutil.ReadAll(r.Body)
        data := []string{}
        err := json.Unmarshal(dataBytes, &amp;data)
        if err != nil </span><span class="cov0" title="0">{ // can't unmarshal json
                badRequestResponseBuilder(w, errors.NewBadRequest(err.Error()), "incomplete_body")
                return
        }</span>

        <span class="cov2" title="2">resp, errList := services.OwnershipVoucherService.ConnectDevices(data)
        if errList != nil </span><span class="cov1" title="1">{
                services.Log.Error("An error occured while trying to connect devices")
                var unknownDevices []string
                for _, err := range errList </span><span class="cov2" title="2">{
                        unknownDevices = append(unknownDevices, err.Error())
                }</span>
                <span class="cov1" title="1">w.WriteHeader(errors.NewBadRequest("unknown_device").GetStatus())
                resp := map[string]interface{}{"error_code": "unknown_device"}
                resp["error_details"] = map[string]interface{}{"unknown": unknownDevices}
                json.NewEncoder(w).Encode(resp)
                return</span>
        }
        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(resp)</span>
}

// validate upload request headers
func validateUploadRequestHeaders(r *http.Request) errors.APIError <span class="cov6" title="6">{
        if r.Header.Get("Content-Type") != "application/cbor" </span><span class="cov1" title="1">{
                return errors.NewBadRequest("Content-Type header must be application/cbor")
        }</span>
        <span class="cov5" title="5">if vNum, err := strconv.Atoi(r.Header.Get("X-Number-Of-Vouchers")); vNum &lt; 0 || err != nil </span><span class="cov2" title="2">{
                return errors.NewBadRequest("X-Number-Of-Vouchers header must be set &amp; greater than zero")
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// validate Content-Type application/json header
func validateContentTypeJSONHeader(r *http.Request) errors.APIError <span class="cov6" title="7">{
        if r.Header.Get("Content-Type") != "application/json" </span><span class="cov2" title="2">{
                return errors.NewBadRequest("Content-Type header must be application/json")
        }</span>
        <span class="cov5" title="5">return nil</span>
}

func validateMiddleware(next http.Handler) http.Handler <span class="cov2" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="24">{
                if r.Body == nil </span><span class="cov4" title="4">{
                        badRequestResponseBuilder(w, errors.NewBadRequest("Body is nil"), "incomplete_body")
                        return
                }</span>
                <span class="cov9" title="20">if r.Header.Get("Accept") != "application/json" </span><span class="cov4" title="4">{
                        badRequestResponseBuilder(w, errors.NewBadRequest("Accept header must be application/json"), "invalid_header")
                        return
                }</span>
                <span class="cov8" title="16">_, ok := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
                if !ok </span><span class="cov1" title="1">{
                        w.WriteHeader(errors.NewInternalServerError().GetStatus())
                        json.NewEncoder(w).Encode(interface{}("Internal server error"))
                        return
                }</span>
                <span class="cov8" title="15">next.ServeHTTP(w, r)</span>
        })
}

// badRequestResponseBuilder builds a response for a bad request
func badRequestResponseBuilder(w http.ResponseWriter, e errors.APIError, errorCode string) <span class="cov9" title="18">{
        w.WriteHeader(e.GetStatus())
        resp := map[string]interface{}{"error_code": errorCode}
        resp["error_details"] = map[string]string{"error_message": e.Error()}
        json.NewEncoder(w).Encode(resp)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package routes

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/go-chi/chi"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/models"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
        "github.com/redhatinsights/edge-api/pkg/services"
        log "github.com/sirupsen/logrus"
)

type tprepoTypeKey int

const tprepoKey tprepoTypeKey = iota

// MakeThirdPartyRepoRouter adds suport for operation on ThirdPartyRepo
func MakeThirdPartyRepoRouter(sub chi.Router) <span class="cov0" title="0">{
        sub.With(validateGetAllThirdPartyRepoFilterParams).With(common.Paginate).Get("/", GetAllThirdPartyRepo) // TODO: Consistent logging
        sub.Post("/", CreateThirdPartyRepo)                                                                     // TODO: Consistent logging
        sub.Route("/{ID}", func(r chi.Router) </span><span class="cov0" title="0">{                                                                 // TODO: Consistent logging
                r.Use(ThirdPartyRepoCtx)                // TODO: Consistent logging
                r.Get("/", GetThirdPartyRepoByID)       // TODO: Consistent logging
                r.Put("/", CreateThirdPartyRepoUpdate)  // TODO: Consistent logging
                r.Delete("/", DeleteThirdPartyRepoByID) // TODO: Consistent logging
        }</span>)
}

var thirdPartyRepoFilters = common.ComposeFilters(
        common.ContainFilterHandler(&amp;common.Filter{
                QueryParam: "name",
                DBField:    "third_party_repos.name",
        }),
        common.CreatedAtFilterHandler(&amp;common.Filter{
                QueryParam: "created_at",
                DBField:    "third_party_repos.created_at",
        }),
        common.CreatedAtFilterHandler(&amp;common.Filter{
                QueryParam: "updated_at",
                DBField:    "third_party_repos.updated_at",
        }),
        common.SortFilterHandler("third_party_repos", "created_at", "DESC"),
)

// A CreateTPRepoRequest model.
type CreateTPRepoRequest struct {
        Repo *models.ThirdPartyRepo
}

// CreateThirdPartyRepo creates Third Party Repository
func CreateThirdPartyRepo(w http.ResponseWriter, r *http.Request) <span class="cov10" title="2">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()
        thirdPartyRepo, err := createRequest(w, r)
        if err != nil </span><span class="cov1" title="1">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">log.Infof("ThirdPartyRepo::create: %#v", thirdPartyRepo)

        account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>

        <span class="cov1" title="1">thirdPartyRepo, err = services.ThirdPartyRepoService.CreateThirdPartyRepo(thirdPartyRepo, account)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                err := errors.NewInternalServerError()
                err.SetTitle("failed creating third party repository")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(&amp;thirdPartyRepo)</span>

}

// createRequest validates request to create ThirdPartyRepo.
func createRequest(w http.ResponseWriter, r *http.Request) (*models.ThirdPartyRepo, error) <span class="cov10" title="2">{
        var tprepo *models.ThirdPartyRepo
        if err := json.NewDecoder(r.Body).Decode(&amp;tprepo); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                err := errors.NewBadRequest("invalid JSON request")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return nil, err
        }</span>

        <span class="cov10" title="2">if err := tprepo.ValidateRequest(); err != nil </span><span class="cov1" title="1">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                return nil, err
        }</span>

        <span class="cov1" title="1">return tprepo, nil</span>
}

// GetAllThirdPartyRepo return all the ThirdPartyRepo
func GetAllThirdPartyRepo(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var tprepo *[]models.ThirdPartyRepo
        var count int64
        result := thirdPartyRepoFilters(r, db.DB)
        account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">pagination := common.GetPagination(r)
        countResult := thirdPartyRepoFilters(r, db.DB.Model(&amp;models.ThirdPartyRepo{})).Where("account = ?", account).Count(&amp;count)
        if countResult.Error != nil </span><span class="cov0" title="0">{
                countErr := errors.NewInternalServerError()
                log.Error(countErr)
                w.WriteHeader(countErr.GetStatus())
                json.NewEncoder(w).Encode(&amp;countErr)
                return
        }</span>
        <span class="cov1" title="1">log.Debugf("r.URL.Query() %v \n", r.URL.Query().Get("sort_by"))
        if r.URL.Query().Get("sort_by") != "name" &amp;&amp; r.URL.Query().Get("sort_by") != "-name" </span><span class="cov1" title="1">{
                result = result.Limit(pagination.Limit).Offset(pagination.Offset).Where("account = ?", account).Find(&amp;tprepo)
        }</span>
        <span class="cov1" title="1">filter := r.URL.Query().Get("filter")
        filterMap := map[string]string{}
        if filter != "" </span><span class="cov0" title="0">{
                filterMap, err = validateFilterMap(filter)
                if err != nil </span><span class="cov0" title="0">{
                        err := errors.NewBadRequest(err.Error())
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
        }
        <span class="cov1" title="1">if err := result.Where(filterMap).Limit(pagination.Limit).Offset(pagination.Offset).Find(&amp;tprepo).Error; err != nil </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("this is not a valid filter. filter must be in name.value")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>

        <span class="cov1" title="1">result = result.Limit(pagination.Limit).Offset(pagination.Offset).Where("account = ?", account).Find(&amp;tprepo)
        if result.Error != nil </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Not Found")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>

        <span class="cov1" title="1">json.NewEncoder(w).Encode(map[string]interface{}{"data": &amp;tprepo, "count": count})</span>

}

// ThirdPartyRepoCtx is a handler to Third Party Repository requests
func ThirdPartyRepoCtx(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var tprepo models.ThirdPartyRepo
                if ID := chi.URLParam(r, "ID"); ID != "" </span><span class="cov0" title="0">{
                        _, err := strconv.Atoi(ID)
                        if err != nil </span><span class="cov0" title="0">{
                                err := errors.NewBadRequest(err.Error())
                                w.WriteHeader(err.GetStatus())
                                json.NewEncoder(w).Encode(&amp;err)
                                return
                        }</span>

                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), tprepoKey, &amp;tprepo)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                }
        })
}

// GetThirdPartyRepoByID gets the Third Party repository by ID from the database
func GetThirdPartyRepoByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        s, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        ID := chi.URLParam(r, "ID")
        tprepo, err := s.ThirdPartyRepoService.GetThirdPartyRepoByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                var responseErr errors.APIError
                switch err.(type) </span>{
                case *services.ThirdPartyRepositoryNotFound:<span class="cov0" title="0">
                        responseErr = errors.NewNotFound(err.Error())</span>
                default:<span class="cov0" title="0">
                        responseErr = errors.NewInternalServerError()
                        responseErr.SetTitle("failed getting third party repository")</span>
                }
                <span class="cov0" title="0">log.Error(responseErr)
                w.WriteHeader(responseErr.GetStatus())
                json.NewEncoder(w).Encode(&amp;responseErr)
                return</span>
        }
        <span class="cov0" title="0">json.NewEncoder(w).Encode(&amp;tprepo)</span>
}

// CreateThirdPartyRepoUpdate updates the existing third party repository
func CreateThirdPartyRepoUpdate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        defer r.Body.Close()
        tprepo, err := createRequest(w, r)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
                err := errors.NewBadRequest(err.Error())
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>

        <span class="cov0" title="0">ID := chi.URLParam(r, "ID")
        err = services.ThirdPartyRepoService.UpdateThirdPartyRepo(tprepo, account, ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                err := errors.NewInternalServerError()
                err.SetTitle("failed updating third party repository")
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        repoDetails, err := services.ThirdPartyRepoService.GetThirdPartyRepoByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(repoDetails)</span>
}

// DeleteThirdPartyRepoByID deletes the third party repository using ID
func DeleteThirdPartyRepoByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        ID := chi.URLParam(r, "ID")

        tprepo, err := s.ThirdPartyRepoService.DeleteThirdPartyRepoByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                var responseErr errors.APIError
                switch err.(type) </span>{
                case *services.ThirdPartyRepositoryNotFound:<span class="cov0" title="0">
                        responseErr = errors.NewNotFound(err.Error())</span>
                default:<span class="cov0" title="0">
                        responseErr = errors.NewInternalServerError()
                        responseErr.SetTitle("failed deleting third party repository")</span>
                }
                <span class="cov0" title="0">log.Error(responseErr)
                w.WriteHeader(responseErr.GetStatus())
                json.NewEncoder(w).Encode(&amp;responseErr)
                return</span>
        }
        <span class="cov0" title="0">_ = tprepo
        json.NewEncoder(w).Encode(&amp;tprepo)</span>
}

func validateGetAllThirdPartyRepoFilterParams(next http.Handler) http.Handler <span class="cov10" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="2">{
                errs := []validationError{}
                if val := r.URL.Query().Get("created_at"); val != "" </span><span class="cov1" title="1">{
                        if _, err := time.Parse(common.LayoutISO, val); err != nil </span><span class="cov1" title="1">{
                                errs = append(errs, validationError{Key: "created_at", Reason: err.Error()})
                        }</span>
                }
                <span class="cov10" title="2">if val := r.URL.Query().Get("sort_by"); val != "" </span><span class="cov1" title="1">{
                        name := val
                        if string(val[0]) == "-" </span><span class="cov0" title="0">{
                                name = val[1:]
                        }</span>
                        <span class="cov1" title="1">if name != "name" &amp;&amp; name != "created_at" &amp;&amp; name != "updated_at" </span><span class="cov1" title="1">{
                                errs = append(errs, validationError{Key: "sort_by", Reason: fmt.Sprintf("%s is not a valid sort_by. Sort-by must be name or created_at or updated_at", name)})
                        }</span>
                }

                <span class="cov10" title="2">if len(errs) == 0 </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov10" title="2">w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(&amp;errs)</span>
        })
}

func validateFilterMap(filter string) (map[string]string, error) <span class="cov0" title="0">{
        splits := strings.Split(filter, ".")
        if len(splits) != 2 </span><span class="cov0" title="0">{
                return nil, errors.NewBadRequest("this is not a valid filter. filter must be name")
        }</span>
        <span class="cov0" title="0">field, value := splits[0], splits[1]
        return map[string]string{field: value}, nil</span>

}
</pre>
		
		<pre class="file" id="file15" style="display: none">package routes

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"

        "github.com/go-chi/chi"
        "github.com/redhatinsights/edge-api/pkg/clients/inventory"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/dependencies"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/models"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
        "github.com/redhatinsights/edge-api/pkg/services"

        log "github.com/sirupsen/logrus"
)

// MakeUpdatesRouter adds support for operations on update
func MakeUpdatesRouter(sub chi.Router) <span class="cov0" title="0">{
        sub.With(common.Paginate).Get("/", GetUpdates) // TODO: Consistent logging
        sub.Post("/", AddUpdate)
        sub.Route("/{updateID}", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(UpdateCtx)                                 // TODO: Consistent logging
                r.Get("/", GetUpdateByID)                        // TODO: Consistent logging
                r.Get("/update-playbook.yml", GetUpdatePlaybook) // TODO: Consistent logging
        }</span>)
        // TODO: This is for backwards compatibility with the previous route
        // Once the frontend starts querying the device
        <span class="cov0" title="0">sub.Route("/device/", MakeDevicesRouter)</span>
}

type updateContextKey int

// UpdateContextKey is the key to Update Context handler
const UpdateContextKey updateContextKey = iota

// UpdateCtx is a handler for Update requests
func UpdateCtx(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var update models.UpdateTransaction
                account, err := common.GetAccount(r)
                if err != nil </span><span class="cov0" title="0">{
                        err := errors.NewBadRequest(err.Error())
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">updateID := chi.URLParam(r, "updateID")
                if updateID == "" </span><span class="cov0" title="0">{
                        err := errors.NewBadRequest("UpdateTransactionID can't be empty")
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">id, err := strconv.Atoi(updateID)
                if err != nil </span><span class="cov0" title="0">{
                        err := errors.NewBadRequest(err.Error())
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">result := db.DB.Preload("DispatchRecords").Preload("Devices").Where("update_transactions.account = ?", account).Joins("Commit").Joins("Repo").Find(&amp;update, id)
                if result.Error != nil </span><span class="cov0" title="0">{
                        err := errors.NewInternalServerError()
                        w.WriteHeader(err.GetStatus())
                        json.NewEncoder(w).Encode(&amp;err)
                        return
                }</span>
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), UpdateContextKey, &amp;update)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GetUpdatePlaybook returns the playbook for a update transaction
func GetUpdatePlaybook(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        update := getUpdate(w, r)
        if update == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">services, _ := r.Context().Value(dependencies.Key).(*dependencies.EdgeAPIServices)
        playbook, err := services.UpdateService.GetUpdatePlaybook(update)
        if err != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
        <span class="cov1" title="1">defer playbook.Close()
        _, err = io.Copy(w, playbook)
        if err != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
                return
        }</span>
}

// GetUpdates returns the updates for the device
func GetUpdates(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var updates []models.UpdateTransaction
        account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        // FIXME - need to sort out how to get this query to be against commit.account
        <span class="cov0" title="0">result := db.DB.Preload("DispatchRecords").Preload("Devices").Where("update_transactions.account = ?", account).Joins("Commit").Joins("Repo").Find(&amp;updates)
        if result.Error != nil </span><span class="cov0" title="0">{
                http.Error(w, result.Error.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">json.NewEncoder(w).Encode(&amp;updates)</span>
}

// UpdatePostJSON contains the update structure for the device
type UpdatePostJSON struct {
        CommitID   uint   `json:"CommitID"`
        DeviceUUID string `json:"DeviceUUID"`
        // TODO: Implement updates by tag
        // Tag        string `json:"Tag"`
}

func updateFromHTTP(w http.ResponseWriter, r *http.Request) (*models.UpdateTransaction, error) <span class="cov0" title="0">{
        log.Infof("updateFromHTTP:: Begin")

        account, err := common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                err.SetTitle("No account found")
                w.WriteHeader(err.GetStatus())
                return nil, err
        }</span>

        <span class="cov0" title="0">var updateJSON UpdatePostJSON
        err = json.NewDecoder(r.Body).Decode(&amp;updateJSON)
        if err != nil </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Invalid JSON")
                w.WriteHeader(err.GetStatus())
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("updateFromHTTP::updateJSON: %#v", updateJSON)

        if updateJSON.CommitID == 0 </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("Must provide a CommitID")
                w.WriteHeader(err.GetStatus())
                return nil, err
        }</span>
        // TODO: Implement update by tag - Add validation per tag
        <span class="cov0" title="0">if updateJSON.DeviceUUID == "" </span><span class="cov0" title="0">{
                err := errors.NewBadRequest("DeviceUUID required.")
                w.WriteHeader(err.GetStatus())
                return nil, err
        }</span>
        <span class="cov0" title="0">client := inventory.InitClient(r.Context())
        var inventory inventory.Response
        // TODO: Implement update by tag
        // if updateJSON.Tag != "" {
        //         inventory, err = client.ReturnDevicesByTag(updateJSON.Tag)
        //         if err != nil || inventory.Count == 0 {
        //                 err := errors.NewNotFound(fmt.Sprintf("No devices found for Tag %s", updateJSON.Tag))
        //                 w.WriteHeader(err.GetStatus())
        //                 return nil, err
        //         }
        // }
        if updateJSON.DeviceUUID != "" </span><span class="cov0" title="0">{
                inventory, err = client.ReturnDevicesByID(updateJSON.DeviceUUID)
                if err != nil || inventory.Count == 0 </span><span class="cov0" title="0">{
                        err := errors.NewNotFound(fmt.Sprintf("No devices found for UUID %s", updateJSON.DeviceUUID))
                        w.WriteHeader(err.GetStatus())
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">log.Infof("updateFromHTTP::inventory: %#v", inventory)

        // Create the models.UpdateTransaction
        update := models.UpdateTransaction{
                Account:  account,
                CommitID: updateJSON.CommitID,
                Status:   models.UpdateStatusCreated,
                // TODO: Implement update by tag
                // Tag:      updateJSON.Tag,
        }

        // Get the models.Commit from the Commit ID passed in via JSON
        commitService := services.NewCommitService(r.Context())
        update.Commit, err = commitService.GetCommitByID(updateJSON.CommitID)
        log.Infof("updateFromHTTP::update.Commit: %#v", update.Commit)
        update.DispatchRecords = []models.DispatchRecord{}
        if err != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                err.SetTitle(fmt.Sprintf("No commit found for CommitID %d", updateJSON.CommitID))
                w.WriteHeader(err.GetStatus())
                return &amp;models.UpdateTransaction{}, err
        }</span>

        //  Removing commit dependency to avoid overwriting the repo
        <span class="cov0" title="0">var repo *models.Repo
        log.Infof("creating new repo for update transaction: %d", update.ID)
        repo = &amp;models.Repo{
                Status: models.RepoStatusBuilding,
        }
        db.DB.Create(&amp;repo)
        update.Repo = repo
        log.Infof("Getting repo info: repo %s, %d", repo.URL, repo.ID)

        devices := update.Devices
        oldCommits := update.OldCommits

        // - populate the update.Devices []Device data
        log.Infof("Devices in this tag %v", inventory.Result)
        for _, device := range inventory.Result </span><span class="cov0" title="0">{
                //  Check for the existence of a Repo that already has this commit and don't duplicate
                var updateDevice *models.Device
                deviceService := services.NewDeviceService(r.Context())
                updateDevice, err = deviceService.GetDeviceByUUID(device.ID)
                if err != nil </span><span class="cov0" title="0">{
                        if !(err.Error() == "record not found") </span><span class="cov0" title="0">{
                                log.Errorf("updateFromHTTP::GetDeviceByUUID::updateDevice: %#v, %#v", repo, err)
                                http.Error(w, err.Error(), http.StatusBadRequest)
                                return &amp;models.UpdateTransaction{}, err
                        }</span>
                        <span class="cov0" title="0">log.Infof("Existing Device not found in database, creating new one: %s", device.ID)
                        updateDevice = &amp;models.Device{
                                UUID: device.ID,
                        }
                        db.DB.Create(&amp;updateDevice)</span>
                }
                <span class="cov0" title="0">updateDevice.RHCClientID = device.Ostree.RHCClientID
                updateDevice.DesiredHash = update.Commit.OSTreeCommit
                result := db.DB.Save(&amp;updateDevice)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return nil, result.Error
                }</span>

                <span class="cov0" title="0">log.Infof("updateFromHTTP::updateDevice: %#v", updateDevice)
                devices = append(devices, *updateDevice)
                log.Infof("updateFromHTTP::devices: %#v", devices)
                update.Devices = devices
                log.Infof("updateFromHTTP::update.Devices: %#v", devices)

                for _, ostreeDeployment := range device.Ostree.RpmOstreeDeployments </span><span class="cov0" title="0">{
                        if ostreeDeployment.Booted </span><span class="cov0" title="0">{
                                log.Infof("updateFromHTTP::ostreeDeployment.Booted: %#v", ostreeDeployment)
                                var oldCommit models.Commit
                                result := db.DB.Where("os_tree_commit = ?", ostreeDeployment.Checksum).First(&amp;oldCommit)
                                log.Infof("updateFromHTTP::result: %#v", result)
                                if result.Error != nil </span><span class="cov0" title="0">{
                                        if result.Error.Error() != "record not found" </span><span class="cov0" title="0">{
                                                log.Errorf("updateFromHTTP::result.Error: %#v", result.Error)
                                                http.Error(w, result.Error.Error(), http.StatusBadRequest)
                                                return &amp;models.UpdateTransaction{}, err
                                        }</span>
                                }
                                <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                                        log.Infof("Old Commit not found in database: %s", ostreeDeployment.Checksum)
                                }</span> else<span class="cov0" title="0"> {
                                        oldCommits = append(oldCommits, oldCommit)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">update.OldCommits = oldCommits
        if err := db.DB.Save(&amp;update).Error; err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("updateFromHTTP::update: %#v", update)
        log.Infof("updateFromHTTP:: END")
        return &amp;update, nil</span>
}

// AddUpdate adds an object to the database for an account
func AddUpdate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Infof("AddUpdate::update:: Begin")
        update, err := updateFromHTTP(w, r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">log.Infof("AddUpdate::update: %#v", update)

        update.Account, err = common.GetAccount(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">result := db.DB.Save(&amp;update)
        if result.Error != nil </span><span class="cov0" title="0">{
                http.Error(w, result.Error.Error(), http.StatusBadRequest)
        }</span>
        <span class="cov0" title="0">service := services.NewUpdateService(r.Context())
        log.Infof("AddUpdate:: call::        service.CreateUpdate :: %d", update.ID)
        go service.CreateUpdate(update.ID)
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(update)</span>

}

// GetUpdateByID obtains an update from the database for an account
func GetUpdateByID(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        update := getUpdate(w, r)
        if update == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">json.NewEncoder(w).Encode(update)</span>
}

func getUpdate(w http.ResponseWriter, r *http.Request) *models.UpdateTransaction <span class="cov10" title="2">{
        ctx := r.Context()
        update, ok := ctx.Value(UpdateContextKey).(*models.UpdateTransaction)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="2">return update</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "context"

        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"
        log "github.com/sirupsen/logrus"
)

// CommitServiceInterface defines the interface to handle the business logic of RHEL for Edge Commits
type CommitServiceInterface interface {
        GetCommitByID(commitID uint) (*models.Commit, error)
        GetCommitByOSTreeCommit(ost string) (*models.Commit, error)
}

// NewCommitService gives a instance of the main implementation of CommitServiceInterface
func NewCommitService(ctx context.Context) CommitServiceInterface <span class="cov0" title="0">{
        return &amp;CommitService{
                ctx: ctx,
        }
}</span>

// CommitService is the main implementation of a CommitServiceInterface
type CommitService struct {
        ctx context.Context
}

// GetCommitByID receives CommitID uint and get a *models.Commit back
func (s *CommitService) GetCommitByID(commitID uint) (*models.Commit, error) <span class="cov0" title="0">{
        log.Debugf("GetCommitByID::commitID: %#v", commitID)
        var commit models.Commit
        result := db.DB.First(&amp;commit, commitID)
        log.Debugf("GetCommitByID::result: %#v", result)
        log.Debugf("GetCommitByID::commit: %#v", commit)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;commit, nil</span>
}

// GetCommitByOSTreeCommit receives an OSTreeCommit string and get a *models.Commit back
func (s *CommitService) GetCommitByOSTreeCommit(ost string) (*models.Commit, error) <span class="cov0" title="0">{
        log.Debugf("GetCommitByOSTreeCommit::ost: %#v", ost)
        var commit models.Commit
        result := db.DB.Where("os_tree_commit = ?", ost).First(&amp;commit)
        log.Debugf("GetCommitByOSTreeCommit::result: %#v", result)
        log.Debugf("GetCommitByOSTreeCommit::commit: %#v", commit)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;commit, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        clowder "github.com/redhatinsights/app-common-go/pkg/api/v1"

        "github.com/segmentio/kafka-go"
        log "github.com/sirupsen/logrus"
)

// ConsumerService is the interface that takes care of our consumer implementation
type ConsumerService interface {
        Start()
}

// KafkaConsumerService is the implementation of a consumer service based on Kafka topics
type KafkaConsumerService struct {
        Reader        *kafka.Reader
        UpdateService UpdateServiceInterface
        RetryMinutes  uint
        config        *clowder.KafkaConfig
}

// NewKafkaConsumerService gives a instance of the Kafka implementation of ConsumerService
func NewKafkaConsumerService(config *clowder.KafkaConfig) ConsumerService <span class="cov8" title="1">{
        // to consume messages
        s := &amp;KafkaConsumerService{
                UpdateService: NewUpdateService(context.Background()),
                RetryMinutes:  5,
                config:        config,
        }
        s.Reader = s.initReader()
        return s
}</span>

func (s *KafkaConsumerService) initReader() *kafka.Reader <span class="cov8" title="1">{
        topic := "platform.playbook-dispatcher.runs"
        brokers := make([]string, len(s.config.Brokers))
        for i, b := range s.config.Brokers </span><span class="cov8" title="1">{
                brokers[i] = fmt.Sprintf("%s:%d", b.Hostname, *b.Port)
        }</span>
        <span class="cov8" title="1">log.WithFields(log.Fields{
                "brokers": brokers, "topic": topic,
        }).Debug("Connecting with Kafka broker")
        // make a new reader that consumes from topic from this consumer group
        r := kafka.NewReader(kafka.ReaderConfig{
                Brokers: brokers,
                Topic:   topic,
                GroupID: "edge-fleet-management-update-playbook",
        })
        return r</span>
}

// ConsumePlaybookDispatcherRuns is the method that consumes from the topic that gives us the execution of playbook from playbook dispatcher service
func (s *KafkaConsumerService) ConsumePlaybookDispatcherRuns() error <span class="cov0" title="0">{
        log.Info("Starting to consume playbook dispatcher's runs")

        for </span><span class="cov0" title="0">{
                m, err := s.Reader.ReadMessage(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{
                                "error": err.Error(),
                        }).Error("Error reading message from Kafka topic")
                        return err
                }</span>
                <span class="cov0" title="0">log.WithFields(log.Fields{
                        "topic":  m.Topic,
                        "offset": m.Offset,
                        "key":    string(m.Key),
                        "value":  string(m.Value),
                }).Debug("Read message from Kafka topic")
                var service string
                for _, h := range m.Headers </span><span class="cov0" title="0">{
                        if h.Key == "service" </span><span class="cov0" title="0">{
                                service = string(h.Value)
                        }</span>
                }
                <span class="cov0" title="0">if service == "edge" </span><span class="cov0" title="0">{
                        err = s.UpdateService.ProcessPlaybookDispatcherRunEvent(m.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                log.WithFields(log.Fields{
                                        "error": err.Error(),
                                }).Error("Error treating Kafka message")
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Debug("Skipping message - it is not from edge service")
                }</span>

        }
}

// RegisterShutdown listens to os signals to wrap up reader work
func (s *KafkaConsumerService) RegisterShutdown() <span class="cov0" title="0">{
        sigint := make(chan os.Signal, 1)
        signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
        &lt;-sigint
        log.Info("Closing Kafka readers...")
        s.Reader.Close()
}</span>

// Start consumers for this application
func (s *KafkaConsumerService) Start() <span class="cov0" title="0">{
        log.Info("Starting consumers...")

        go s.RegisterShutdown()
        for </span><span class="cov0" title="0">{
                // The only way to actually exit this for is sending an exit signal to the app
                err := s.ConsumePlaybookDispatcherRuns()
                log.WithFields(log.Fields{
                        "error":          err.Error(),
                        "minutesToRetry": s.RetryMinutes,
                }).Error("There was en error connecting to the broker. Retry in a few minutes.")
                time.Sleep(time.Minute * time.Duration(s.RetryMinutes))
                s.Reader = s.initReader()
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"

        version "github.com/knqyf263/go-rpm-version"
        "github.com/redhatinsights/edge-api/pkg/clients/inventory"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"
        log "github.com/sirupsen/logrus"
)

// DeviceServiceInterface defines the interface to handle the business logic of RHEL for Edge Devices
type DeviceServiceInterface interface {
        GetDeviceByID(deviceID uint) (*models.Device, error)
        GetDeviceByUUID(deviceUUID string) (*models.Device, error)
        GetUpdateAvailableForDeviceByUUID(deviceUUID string) ([]ImageUpdateAvailable, error)
        GetDeviceImageInfo(deviceUUID string) (*ImageInfo, error)
        GetDeviceDetails(deviceUUID string) (*DeviceDetails, error)
}

// NewDeviceService gives a instance of the main implementation of DeviceServiceInterface
func NewDeviceService(ctx context.Context) DeviceServiceInterface <span class="cov0" title="0">{
        return &amp;DeviceService{
                ctx:           ctx,
                updateService: NewUpdateService(ctx),
                inventory:     inventory.InitClient(ctx),
        }
}</span>

// DeviceService is the main implementation of a DeviceServiceInterface
type DeviceService struct {
        ctx           context.Context
        updateService UpdateServiceInterface
        inventory     inventory.ClientInterface
}

// DeviceDetails is a Device with Image and Update transactions
type DeviceDetails struct {
        Device             *models.Device              `json:"Device,omitempty"`
        Image              *ImageInfo                  `json:"ImageInfo"`
        UpdateTransactions *[]models.UpdateTransaction `json:"UpdateTransactions,omitempty"`
}

// GetDeviceByID receives DeviceID uint and get a *models.Device back
func (s *DeviceService) GetDeviceByID(deviceID uint) (*models.Device, error) <span class="cov0" title="0">{
        log.Debugf("GetDeviceByID::deviceID: %#v", deviceID)
        var device models.Device
        result := db.DB.First(&amp;device, deviceID)
        log.Debugf("GetDeviceByID::result: %#v", result)
        log.Debugf("GetDeviceByID::device: %#v", device)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;device, nil</span>
}

// GetDeviceByUUID receives UUID string and get a *models.Device back
func (s *DeviceService) GetDeviceByUUID(deviceUUID string) (*models.Device, error) <span class="cov0" title="0">{
        log.Debugf("GetDeviceByUUID::deviceUUID: %#v", deviceUUID)
        var device models.Device
        result := db.DB.Where("uuid = ?", deviceUUID).First(&amp;device)
        log.Debugf("GetDeviceByUUID::result: %#v", result)
        log.Debugf("GetDeviceByUUID::device: %#v", device)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;device, nil</span>
}

// GetDeviceDetails provides details for a given Device UUID
func (s *DeviceService) GetDeviceDetails(deviceUUID string) (*DeviceDetails, error) <span class="cov0" title="0">{
        imageInfo, err := s.GetDeviceImageInfo(deviceUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">device, err := s.GetDeviceByUUID(deviceUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("Could not find device on the devices table yet - %s", deviceUUID)
        }</span>
        // In order to have an update transaction for a device it must be a least created
        <span class="cov0" title="0">var updates *[]models.UpdateTransaction
        if device != nil </span><span class="cov0" title="0">{
                updates, err = s.updateService.GetUpdateTransactionsForDevice(device)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">details := &amp;DeviceDetails{
                Device:             device,
                Image:              imageInfo,
                UpdateTransactions: updates,
        }
        return details, nil</span>
}

// ImageUpdateAvailable contains image and differences between current and available commits
type ImageUpdateAvailable struct {
        Image       models.Image `json:"Image"`
        PackageDiff DeltaDiff    `json:"PackageDiff"`
}

// DeltaDiff provides package difference details between current and available commits
type DeltaDiff struct {
        Added    []models.InstalledPackage `json:"Added"`
        Removed  []models.InstalledPackage `json:"Removed"`
        Upgraded []models.InstalledPackage `json:"Upgraded"`
}

// ImageInfo contains Image with updates available and rollback image
type ImageInfo struct {
        Image            models.Image            `json:"Image"`
        UpdatesAvailable *[]ImageUpdateAvailable `json:"UpdatesAvailable,omitempty"`
        Rollback         *models.Image           `json:"RollbackImage,omitempty"`
}

// GetUpdateAvailableForDeviceByUUID returns if exists update for the current image at the device.
func (s *DeviceService) GetUpdateAvailableForDeviceByUUID(deviceUUID string) ([]ImageUpdateAvailable, error) <span class="cov6" title="6">{
        var lastDeployment inventory.OSTree
        var imageDiff []ImageUpdateAvailable
        device, err := s.inventory.ReturnDevicesByID(deviceUUID)
        if err != nil || device.Total != 1 </span><span class="cov3" title="2">{
                return nil, new(DeviceNotFoundError)
        }</span>

        <span class="cov5" title="4">lastDevice := device.Result[len(device.Result)-1]
        for _, rpmOstree := range lastDevice.Ostree.RpmOstreeDeployments </span><span class="cov5" title="4">{
                if rpmOstree.Booted </span><span class="cov5" title="4">{
                        lastDeployment = rpmOstree
                        break</span>
                }
        }

        <span class="cov5" title="4">var images []models.Image
        var currentImage models.Image
        result := db.DB.Model(&amp;models.Image{}).Joins("Commit").Where("OS_Tree_Commit = ?", lastDeployment.Checksum).First(&amp;currentImage)
        if result.Error != nil || result.RowsAffected == 0 </span><span class="cov1" title="1">{
                log.Error(result.Error)
                return nil, new(DeviceNotFoundError)
        }</span>

        <span class="cov4" title="3">err = db.DB.Model(&amp;currentImage.Commit).Association("InstalledPackages").Find(&amp;currentImage.Commit.InstalledPackages)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(result.Error)
                return nil, new(DeviceNotFoundError)
        }</span>

        <span class="cov4" title="3">updates := db.DB.Where("Image_set_id = ? and Images.Status = ? and Images.Id &gt; ?", currentImage.ImageSetID, models.ImageStatusSuccess, currentImage.ID).Joins("Commit").Order("Images.updated_at desc").Find(&amp;images)
        if updates.Error != nil </span><span class="cov0" title="0">{
                return nil, new(UpdateNotFoundError)
        }</span>
        <span class="cov4" title="3">if updates.RowsAffected == 0 </span><span class="cov1" title="1">{
                return imageDiff, nil
        }</span>

        <span class="cov3" title="2">for _, upd := range images </span><span class="cov3" title="2">{
                db.DB.First(&amp;upd.Commit, upd.CommitID)
                db.DB.Model(&amp;upd.Commit).Association("InstalledPackages").Find(&amp;upd.Commit.InstalledPackages)
                db.DB.Model(&amp;upd).Association("Packages").Find(&amp;upd.Packages)
                var delta ImageUpdateAvailable
                diff := getDiffOnUpdate(currentImage, upd)
                upd.Commit.InstalledPackages = nil // otherwise the frontend will get the whole list of installed packages
                delta.Image = upd
                delta.PackageDiff = diff
                imageDiff = append(imageDiff, delta)
        }</span>
        <span class="cov3" title="2">return imageDiff, nil</span>
}

func getPackageDiff(a, b []models.InstalledPackage) []models.InstalledPackage <span class="cov6" title="6">{
        var diff []models.InstalledPackage
        pkgs := make(map[string]models.InstalledPackage)
        for _, pkg := range b </span><span class="cov10" title="15">{
                pkgs[pkg.Name] = pkg
        }</span>
        <span class="cov6" title="6">for _, pkg := range a </span><span class="cov10" title="15">{
                if _, ok := pkgs[pkg.Name]; !ok </span><span class="cov7" title="7">{
                        diff = append(diff, pkg)
                }</span>
        }
        <span class="cov6" title="6">return diff</span>
}

func getVersionDiff(new, old []models.InstalledPackage) []models.InstalledPackage <span class="cov4" title="3">{
        var diff []models.InstalledPackage
        oldPkgs := make(map[string]models.InstalledPackage)
        for _, pkg := range old </span><span class="cov7" title="8">{
                oldPkgs[pkg.Name] = pkg
        }</span>
        <span class="cov4" title="3">for _, pkg := range new </span><span class="cov7" title="7">{
                if oldPkg, ok := oldPkgs[pkg.Name]; ok </span><span class="cov5" title="4">{
                        oldPkgVersion := version.NewVersion(oldPkg.Version)
                        newPkgVersion := version.NewVersion(pkg.Version)
                        if newPkgVersion.GreaterThan(oldPkgVersion) </span><span class="cov4" title="3">{
                                diff = append(diff, pkg)
                        }</span>
                }
        }
        <span class="cov4" title="3">return diff</span>
}

func getDiffOnUpdate(oldImg models.Image, newImg models.Image) DeltaDiff <span class="cov4" title="3">{
        results := DeltaDiff{
                Added:    getPackageDiff(newImg.Commit.InstalledPackages, oldImg.Commit.InstalledPackages),
                Removed:  getPackageDiff(oldImg.Commit.InstalledPackages, newImg.Commit.InstalledPackages),
                Upgraded: getVersionDiff(newImg.Commit.InstalledPackages, oldImg.Commit.InstalledPackages),
        }
        return results
}</span>

// GetDeviceImageInfo returns the information of a running image for a device
func (s *DeviceService) GetDeviceImageInfo(deviceUUID string) (*ImageInfo, error) <span class="cov3" title="2">{
        var ImageInfo ImageInfo
        var currentImage models.Image
        var rollback *models.Image
        var lastDeployment inventory.OSTree
        device, err := s.inventory.ReturnDevicesByID(deviceUUID)
        if err != nil || device.Total != 1 </span><span class="cov0" title="0">{
                return nil, new(DeviceNotFoundError)
        }</span>

        <span class="cov3" title="2">lastDevice := device.Result[len(device.Result)-1]

        for _, rpmOstree := range lastDevice.Ostree.RpmOstreeDeployments </span><span class="cov3" title="2">{
                if rpmOstree.Booted </span><span class="cov3" title="2">{
                        lastDeployment = rpmOstree
                        break</span>
                }
        }

        <span class="cov3" title="2">result := db.DB.Model(&amp;models.Image{}).Joins("Commit").Where("OS_Tree_Commit = ?", lastDeployment.Checksum).First(&amp;currentImage)

        if result.Error != nil || result == nil </span><span class="cov1" title="1">{
                log.Error(result.Error)
                return nil, new(ImageNotFoundError)
        }</span>
        <span class="cov1" title="1">if currentImage.ImageSetID != nil </span><span class="cov1" title="1">{
                db.DB.Where("Image_Set_Id = ? and id &lt; ?", currentImage.ImageSetID, currentImage.ID).Last(&amp;rollback)
        }</span>
        <span class="cov1" title="1">updateAvailable, err := s.GetUpdateAvailableForDeviceByUUID(deviceUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                return nil, err
        }</span> else<span class="cov1" title="1"> if updateAvailable != nil </span><span class="cov1" title="1">{
                ImageInfo.UpdatesAvailable = &amp;updateAvailable
        }</span>
        <span class="cov1" title="1">ImageInfo.Rollback = rollback
        ImageInfo.Image = currentImage

        return &amp;ImageInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

// DeviceNotFoundError indicates the device was not found
type DeviceNotFoundError struct{}

func (e *DeviceNotFoundError) Error() string <span class="cov0" title="0">{
        return "Device was not found"
}</span>

// UpdateNotFoundError indicates the update was not found
type UpdateNotFoundError struct{}

func (e *UpdateNotFoundError) Error() string <span class="cov0" title="0">{
        return "Update was not found"
}</span>

// ImageNotFoundError indicates the image was not found
type ImageNotFoundError struct{}

func (e *ImageNotFoundError) Error() string <span class="cov0" title="0">{
        return "image is not found"
}</span>

// AccountNotSet indicates the account was nil
type AccountNotSet struct{}

func (e *AccountNotSet) Error() string <span class="cov0" title="0">{
        return "Account is not set"
}</span>

// IDMustBeInteger indicates the ID is required to be an integer value
type IDMustBeInteger struct{}

func (e *IDMustBeInteger) Error() string <span class="cov0" title="0">{
        return "ID needs to be an integer"
}</span>

// ThirdPartyRepositoryNotFound indicates the Third Party Repository was not found
type ThirdPartyRepositoryNotFound struct{}

func (e *ThirdPartyRepositoryNotFound) Error() string <span class="cov0" title="0">{
        return "third party repository was not found"
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "fmt"
        "io"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/edge-api/pkg/services/files"
)

// FilesService is the interface for Files-related service information
type FilesService interface {
        GetFile(path string) (io.ReadCloser, error)
        GetExtractor() files.Extractor
        GetUploader() files.Uploader
        GetDownloader() files.Downloader
}

// S3FilesService contains S3 files-related information
type S3FilesService struct {
        Client     *s3.S3
        Bucket     string
        extractor  files.Extractor
        uploader   files.Uploader
        downloader files.Downloader
}

// NewFilesService creates a new service to handle files
func NewFilesService() FilesService <span class="cov10" title="8">{
        cfg := config.Get()
        var sess *session.Session
        if cfg.Debug </span><span class="cov4" title="2">{
                sess = session.Must(session.NewSessionWithOptions(session.Options{
                        // Force enable Shared Config support
                        SharedConfigState: session.SharedConfigEnable,
                }))
        }</span> else<span class="cov8" title="6"> {
                var err error
                sess, err = session.NewSession(&amp;aws.Config{
                        Region:      cfg.BucketRegion,
                        Credentials: credentials.NewStaticCredentials(cfg.AccessKey, cfg.SecretKey, ""),
                })
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
        <span class="cov10" title="8">client := s3.New(sess)
        return &amp;S3FilesService{
                Client:     client,
                Bucket:     cfg.BucketName,
                extractor:  files.NewExtractor(),
                uploader:   files.NewUploader(),
                downloader: files.NewDownloader(),
        }</span>
}

// GetExtractor retuns a new extractor for files
func (s *S3FilesService) GetExtractor() files.Extractor <span class="cov0" title="0">{
        return s.extractor
}</span>

// GetUploader retuns a new uploader for files
func (s *S3FilesService) GetUploader() files.Uploader <span class="cov0" title="0">{
        return s.uploader
}</span>

// GetDownloader retuns a new downloads for files
func (s *S3FilesService) GetDownloader() files.Downloader <span class="cov0" title="0">{
        return s.downloader
}</span>

// GetFile retuns the file given a path
func (s *S3FilesService) GetFile(path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        o, err := s.Client.GetObject(&amp;s3.GetObjectInput{
                Bucket: aws.String(s.Bucket),
                Key:    aws.String(path),
        })

        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        case s3.ErrCodeNoSuchKey:<span class="cov0" title="0">
                                return nil, fmt.Errorf("the object %s was not found on the S3 bucket", path)</span>
                        case s3.ErrCodeInvalidObjectState:<span class="cov0" title="0">
                                return nil, fmt.Errorf("the object %s was not found on the S3 bucket because of an invalid state", path)</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("something wrong happened while reading from the S3 bucket")</span>
                        }
                }
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return o.Body, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package files

import (
        "io"
        "net/http"
        "os"
)

// Downloader is the interface that downloads a source into a path
type Downloader interface {
        DownloadToPath(source string, destinationPath string) error
}

// NewDownloader returns the main downloader used by Edge API
func NewDownloader() Downloader <span class="cov0" title="0">{
        return &amp;HTTPDownloader{}
}</span>

// HTTPDownloader implements Downloader and downloads from a URL through HTTP
type HTTPDownloader struct{}

// DownloadToPath download function that puts the source_url into the destination_path on the local filesystem
func (d *HTTPDownloader) DownloadToPath(sourceURL string, destinationPath string) error <span class="cov0" title="0">{

        resp, err := http.Get(sourceURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        out, err := os.Create(destinationPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        _, err = io.Copy(out, resp.Body)
        return err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package files

import (
        "archive/tar"
        "io"
        "os"
        "path/filepath"
)

// Extractor defines methods to extract files to path
type Extractor interface {
        Extract(rc io.ReadCloser, dst string) error
}

// NewExtractor returns the main extractor used by EdgeAPI
func NewExtractor() Extractor <span class="cov1" title="1">{
        return &amp;TARFileExtractor{}
}</span>

// TARFileExtractor implements a method to extract TAR files into a path
type TARFileExtractor struct{}

// Extract extracts file to destination path
func (f *TARFileExtractor) Extract(rc io.ReadCloser, dst string) error <span class="cov1" title="1">{
        defer rc.Close()
        tarReader := tar.NewReader(rc)
        for </span><span class="cov10" title="4">{
                header, err := tarReader.Next()
                if err == io.EOF </span><span class="cov1" title="1">{
                        break</span>
                } else<span class="cov8" title="3"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="3">path := filepath.Join(dst, header.Name)
                info := header.FileInfo()
                if info.IsDir() </span><span class="cov0" title="0">{
                        if err = os.MkdirAll(path, info.Mode()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="3">file, err := os.OpenFile(path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, info.Mode())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="3">_, err = io.Copy(file, tarReader)
                if err != nil </span><span class="cov0" title="0">{
                        file.Close()
                        return err
                }</span>
                <span class="cov8" title="3">file.Close()</span>
        }
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package files

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        "github.com/redhatinsights/edge-api/config"
        log "github.com/sirupsen/logrus"
)

//Uploader is an interface for uploading repository
type Uploader interface {
        UploadRepo(src string, account string) (string, error)
        UploadFile(fname string, uploadPath string) (string, error)
}

// NewUploader returns the uploader used by EdgeAPI based on configurations
func NewUploader() Uploader <span class="cov0" title="0">{
        cfg := config.Get()
        var uploader Uploader
        uploader = &amp;FileUploader{
                BaseDir: "./",
        }
        if cfg.BucketName != "" </span><span class="cov0" title="0">{
                uploader = newS3Uploader()
        }</span>
        <span class="cov0" title="0">return uploader</span>
}

// S3Uploader defines the mechanism to upload data to S3
type S3Uploader struct {
        Client            *s3.S3
        S3ManagerUploader *s3manager.Uploader
        Bucket            string
}

// FileUploader isn't actually an uploader but implements the interface in
// order to allow the workflow to be done to completion on a local machine
// without S3
type FileUploader struct {
        BaseDir string
}

// UploadRepo is Basically a dummy function that returns the src, but allows offline
// development without S3 and satisfies the interface
func (u *FileUploader) UploadRepo(src string, account string) (string, error) <span class="cov0" title="0">{
        return src, nil
}</span>

// UploadFile is Basically a dummy function that returns no error but allows offline
// development without S3 and satisfies the interface
func (u *FileUploader) UploadFile(fname string, uploadPath string) (string, error) <span class="cov0" title="0">{
        return fname, nil
}</span>

func newS3Uploader() *S3Uploader <span class="cov0" title="0">{
        cfg := config.Get()
        var sess *session.Session
        if cfg.Debug </span><span class="cov0" title="0">{
                sess = session.Must(session.NewSessionWithOptions(session.Options{
                        // Force enable Shared Config support
                        SharedConfigState: session.SharedConfigEnable,
                }))
        }</span> else<span class="cov0" title="0"> {
                var err error
                sess, err = session.NewSession(&amp;aws.Config{
                        Region:      cfg.BucketRegion,
                        Credentials: credentials.NewStaticCredentials(cfg.AccessKey, cfg.SecretKey, ""),
                })
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
        <span class="cov0" title="0">client := s3.New(sess)
        uploader := s3manager.NewUploader(sess, func(u *s3manager.Uploader) </span><span class="cov0" title="0">{
                u.Concurrency = 1
        }</span>)
        <span class="cov0" title="0">return &amp;S3Uploader{
                Client:            client,
                S3ManagerUploader: uploader,
                Bucket:            cfg.BucketName,
        }</span>
}

//Struct that contains all details required to upload a file to a destination
type uploadDetails struct {
        fileName   string
        uploadPath string
        uploader   *S3Uploader
        done       chan bool
        count      int
}

func worker(uploadQueue chan *uploadDetails) <span class="cov0" title="0">{
        for p := range uploadQueue </span><span class="cov0" title="0">{
                fname, err := p.uploader.UploadFile(p.fileName, p.uploadPath)
                log.Tracef("Filename: %s with counter %d was uploaded successfully", fname, p.count)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error: %v", err)
                }</span>
                <span class="cov0" title="0">p.done &lt;- true
                log.Tracef("Filename: %s with counter %d was done uploading", fname, p.count)</span>
        }
}

// UploadRepo uploads the repo to a backing object storage bucket
// the repository is uploaded to bucket/$account/$name/
func (u *S3Uploader) UploadRepo(src string, account string) (string, error) <span class="cov0" title="0">{
        cfg := config.Get()

        log.Debugf("S3Uploader::UploadRepo::src: %#v", src)
        log.Debugf("S3Uploader::UploadRepo::account: %#v", account)

        //Wait group is created per request
        //this allows multiple repo's to be independently uploaded simultaneously
        count := 0

        var uploadDetailsList []*uploadDetails

        filepath.Walk(src, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("incoming error!: %#v", err)
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">res := new(uploadDetails)
                res.fileName = path
                res.uploadPath = fmt.Sprintf("%s/%s", account, strings.TrimPrefix(path, cfg.RepoTempPath))
                res.uploader = u
                res.count = count
                res.done = make(chan bool)
                uploadDetailsList = append(uploadDetailsList, res)
                count++
                return nil</span>
        })

        <span class="cov0" title="0">log.Infof("Files are being uploaded.... %d files to upload", len(uploadDetailsList))

        uploadQueue := make(chan *uploadDetails, len(uploadDetailsList))
        for _, u := range uploadDetailsList </span><span class="cov0" title="0">{
                uploadQueue &lt;- u
        }</span>

        <span class="cov0" title="0">numberOfWorkers := cfg.UploadWorkers
        for i := 0; i &lt; numberOfWorkers; i++ </span><span class="cov0" title="0">{
                go worker(uploadQueue)
        }</span>

        <span class="cov0" title="0">for i, u := range uploadDetailsList </span><span class="cov0" title="0">{
                &lt;-u.done
                log.Tracef("%d file is done", i)
                close(u.done)
        }</span>
        <span class="cov0" title="0">log.Infof("Files are done uploading...")
        close(uploadQueue)
        log.Infof("Channel is closed...")
        region := *u.Client.Config.Region
        s3URL := fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s/%s", u.Bucket, region, account, strings.TrimPrefix(src, cfg.RepoTempPath))
        return s3URL, nil</span>
}

// UploadFile takes a Filename path as a string and then uploads that to
// the supplied location in s3
func (u *S3Uploader) UploadFile(fname string, uploadPath string) (string, error) <span class="cov0" title="0">{
        log.Tracef("S3Uploader::UploadFileToS3::fname: %#v", fname)
        log.Tracef("S3Uploader::UploadFileToS3::S3path: %#v", uploadPath)
        f, err := os.Open(fname)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open file %q, %v", fname, err)
        }</span>
        // Upload the file to S3.
        <span class="cov0" title="0">result, err := u.Client.PutObject(&amp;s3.PutObjectInput{
                Bucket: aws.String(u.Bucket),
                Key:    aws.String(uploadPath),
                Body:   f,
                ACL:    aws.String("public-read"),
        })

        log.Tracef("S3Uploader::UploadRepo::result: %#v", result)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">f.Close()
        region := *u.Client.Config.Region
        s3URL := fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s", u.Bucket, region, uploadPath)
        return s3URL, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package services

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "os/signal"
        "strconv"
        "sync"
        "syscall"
        "text/template"
        "time"

        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/edge-api/pkg/clients/imagebuilder"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/models"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
        log "github.com/sirupsen/logrus"

        "gorm.io/gorm"
)

// WaitGroup is the waitg roup for pending image builds
var WaitGroup sync.WaitGroup

// ImageServiceInterface defines the interface that helps handle
// the business logic of creating RHEL For Edge Images
type ImageServiceInterface interface {
        CreateImage(image *models.Image, account string) error
        UpdateImage(image *models.Image, previousImage *models.Image) error
        AddUserInfo(image *models.Image) error
        UpdateImageStatus(image *models.Image) (*models.Image, error)
        SetErrorStatusOnImage(err error, i *models.Image)
        CreateRepoForImage(i *models.Image) (*models.Repo, error)
        GetImageByID(id string) (*models.Image, error)
        GetUpdateInfo(image models.Image) ([]ImageUpdateAvailable, error)
        AddPackageInfo(image *models.Image) (ImageDetail, error)
        GetImageByOSTreeCommitHash(commitHash string) (*models.Image, error)
        CheckImageName(name, account string) (bool, error)
        RetryCreateImage(image *models.Image) error
}

// NewImageService gives a instance of the main implementation of a ImageServiceInterface
func NewImageService(ctx context.Context, log *log.Entry) ImageServiceInterface <span class="cov0" title="0">{
        return &amp;ImageService{
                ctx:          ctx,
                imageBuilder: imagebuilder.InitClient(ctx, log),
                log:          log,
                repoBuilder:  NewRepoBuilder(ctx, log),
        }
}</span>

// ImageService is the main implementation of a ImageServiceInterface
type ImageService struct {
        ctx context.Context
        log *log.Entry

        imageBuilder imagebuilder.ClientInterface
        repoBuilder  RepoBuilderInterface
}

// CreateImage creates an Image for an Account on Image Builder and on our database
func (s *ImageService) CreateImage(image *models.Image, account string) error <span class="cov0" title="0">{
        var imageSet models.ImageSet
        imageSet.Account = account
        imageSet.Name = image.Name
        imageSet.Version = image.Version
        set := db.DB.Create(&amp;imageSet)
        if set.Error == nil </span><span class="cov0" title="0">{
                image.ImageSetID = &amp;imageSet.ID
        }</span>
        <span class="cov0" title="0">image, err := s.imageBuilder.ComposeCommit(image)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">image.Account = account
        image.Commit.Account = account
        image.Commit.Status = models.ImageStatusBuilding
        image.Status = models.ImageStatusBuilding
        // TODO: Remove code when frontend is not using ImageType on the table
        if image.HasOutputType(models.ImageTypeInstaller) </span><span class="cov0" title="0">{
                image.ImageType = models.ImageTypeInstaller
        }</span> else<span class="cov0" title="0"> {
                image.ImageType = models.ImageTypeCommit
        }</span>
        // TODO: End of remove block
        <span class="cov0" title="0">if image.HasOutputType(models.ImageTypeInstaller) </span><span class="cov0" title="0">{
                image.Installer.Status = models.ImageStatusCreated
                image.Installer.Account = image.Account
                tx := db.DB.Create(&amp;image.Installer)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return tx.Error
                }</span>
        }
        <span class="cov0" title="0">tx := db.DB.Create(&amp;image.Commit)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">tx = db.DB.Create(&amp;image)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>

        <span class="cov0" title="0">go s.postProcessImage(image.ID)

        return nil</span>
}

// UpdateImage updates an image, adding a new version of this image to an imageset
func (s *ImageService) UpdateImage(image *models.Image, previousImage *models.Image) error <span class="cov3" title="2">{
        if previousImage == nil </span><span class="cov1" title="1">{
                return new(ImageNotFoundError)
        }</span>
        <span class="cov1" title="1">if previousImage.Status == models.ImageStatusSuccess </span><span class="cov0" title="0">{
                // Previous image was built sucessfully
                var currentImageSet models.ImageSet
                result := db.DB.Where("Id = ?", previousImage.ImageSetID).First(&amp;currentImageSet)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return result.Error
                }</span>
                <span class="cov0" title="0">currentImageSet.Version = currentImageSet.Version + 1
                image.ImageSetID = previousImage.ImageSetID
                if err := db.DB.Save(currentImageSet).Error; err != nil </span><span class="cov0" title="0">{
                        return result.Error
                }</span>
                <span class="cov0" title="0">if image.Commit.OSTreeParentCommit == "" </span><span class="cov0" title="0">{
                        if previousImage.Commit.OSTreeParentCommit != "" </span><span class="cov0" title="0">{
                                image.Commit.OSTreeParentCommit = previousImage.Commit.OSTreeParentCommit
                        }</span> else<span class="cov0" title="0"> {
                                var repo *RepoService
                                repoURL, err := repo.GetRepoByID(previousImage.Commit.RepoID)
                                if err != nil </span><span class="cov0" title="0">{
                                        err := errors.NewBadRequest(fmt.Sprintf("Commit Repo wasn't found in the database: #%v", image.Commit.ID))
                                        return err
                                }</span>
                                <span class="cov0" title="0">image.Commit.OSTreeParentCommit = repoURL.URL</span>
                        }
                }
                <span class="cov0" title="0">if image.Commit.OSTreeRef == "" </span><span class="cov0" title="0">{
                        if previousImage.Commit.OSTreeRef != "" </span><span class="cov0" title="0">{
                                image.Commit.OSTreeRef = previousImage.Commit.OSTreeRef
                        }</span> else<span class="cov0" title="0"> {
                                image.Commit.OSTreeRef = config.Get().DefaultOSTreeRef
                        }</span>
                }
        } else<span class="cov1" title="1"> {
                // Previous image was not built sucessfully
                s.log.WithField("previousImageID", previousImage.ID).Info("Creating an update based on a image with a status that is not success")
        }</span>
        <span class="cov1" title="1">image, err := s.imageBuilder.ComposeCommit(image)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">image.Account = previousImage.Account
        image.Commit.Account = previousImage.Account
        image.Commit.Status = models.ImageStatusBuilding
        image.Status = models.ImageStatusBuilding
        // TODO: Remove code when frontend is not using ImageType on the table
        if image.HasOutputType(models.ImageTypeInstaller) </span><span class="cov0" title="0">{
                image.ImageType = models.ImageTypeInstaller
        }</span> else<span class="cov0" title="0"> {
                image.ImageType = models.ImageTypeCommit
        }</span>
        // TODO: End of remove block
        <span class="cov0" title="0">if image.HasOutputType(models.ImageTypeInstaller) </span><span class="cov0" title="0">{
                image.Installer.Status = models.ImageStatusCreated
                image.Installer.Account = image.Account
                tx := db.DB.Create(&amp;image.Installer)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return tx.Error
                }</span>
        }
        <span class="cov0" title="0">tx := db.DB.Create(&amp;image.Commit)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">tx = db.DB.Create(&amp;image)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>

        <span class="cov0" title="0">s.log = s.log.WithFields(log.Fields{"imageID": image.ID, "commitID": image.Commit.ID})
        go s.postProcessImage(image.ID)

        return nil</span>
}

func (s *ImageService) postProcessInstaller(i *models.Image) error <span class="cov0" title="0">{
        s.log.Debug("Post processing installer")
        i, err := s.imageBuilder.ComposeInstaller(i)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">i.Installer.Status = models.ImageStatusBuilding
        tx := db.DB.Save(&amp;i.Installer)
        if tx.Error != nil </span><span class="cov0" title="0">{
                s.log.WithField("error", err.Error()).Error("Error setting installer building status")
                return err
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                i, err := s.UpdateImageStatus(i)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithField("error", err.Error()).Error("Update image status error")
                        return err
                }</span>
                <span class="cov0" title="0">if i.Installer.Status != models.ImageStatusBuilding </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Minute)</span>
        }

        <span class="cov0" title="0">if i.Installer.Status == models.ImageStatusSuccess </span><span class="cov0" title="0">{
                err = s.AddUserInfo(i)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithField("error", err.Error()).Error("Kickstart file injection failed")
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ImageService) postProcessCommit(image *models.Image) error <span class="cov0" title="0">{
        s.log.Debug("Post processing commit")
        for </span><span class="cov0" title="0">{
                i, err := s.UpdateImageStatus(image)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithField("error", err.Error()).Error("Update image status error")
                        return err
                }</span>
                <span class="cov0" title="0">if i.Commit.Status != models.ImageStatusBuilding </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Minute)</span>
        }

        <span class="cov0" title="0">if image.Commit.Status == models.ImageStatusSuccess </span><span class="cov0" title="0">{
                i, err := s.imageBuilder.GetMetadata(image)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithField("error", err.Error()).Error("Failed getting metadata from image builder")
                        s.SetErrorStatusOnImage(err, i)
                        return err
                }</span>

                <span class="cov0" title="0">_, err = s.CreateRepoForImage(image)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.WithField("error", err.Error()).Error("Failed creating repo for image")
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ImageService) setFinalImageStatus(i *models.Image) error <span class="cov8" title="9">{
        // image status can be success if all output types are successful
        // if any status are not final (success/error) then sets to error
        // image status is error if any output status is error
        success := true
        for _, out := range i.OutputTypes </span><span class="cov10" title="12">{
                if out == models.ImageTypeCommit </span><span class="cov7" title="6">{
                        if i.Commit == nil || i.Commit.Status != models.ImageStatusSuccess </span><span class="cov3" title="2">{
                                success = false
                        }</span>
                        <span class="cov7" title="6">if i.Commit.Status == models.ImageStatusBuilding </span><span class="cov1" title="1">{
                                success = false
                                i.Commit.Status = models.ImageStatusError
                                db.DB.Save(i.Commit)
                        }</span>
                }
                <span class="cov10" title="12">if out == models.ImageTypeInstaller </span><span class="cov7" title="6">{
                        if i.Installer == nil || i.Installer.Status != models.ImageStatusSuccess </span><span class="cov6" title="4">{
                                success = false
                        }</span>
                        <span class="cov7" title="6">if i.Installer.Status == models.ImageStatusBuilding </span><span class="cov3" title="2">{
                                success = false
                                i.Installer.Status = models.ImageStatusError
                                db.DB.Save(i.Installer)
                        }</span>
                }
        }

        <span class="cov8" title="9">if success </span><span class="cov4" title="3">{
                i.Status = models.ImageStatusSuccess
        }</span> else<span class="cov7" title="6"> {
                i.Status = models.ImageStatusError
        }</span>

        <span class="cov8" title="9">tx := db.DB.Save(i)
        return tx.Error</span>
}

// Every log message in this method already has commit id and image id injected
func (s *ImageService) postProcessImage(id uint) <span class="cov0" title="0">{
        s.log.Debug("Post processing image")
        var i *models.Image
        db.DB.Joins("Commit").Joins("Installer").First(&amp;i, id)

        WaitGroup.Add(1) // Processing one image
        defer func() </span><span class="cov0" title="0">{
                WaitGroup.Done() // Done with one image (successfuly or not)
                s.log.Debug("Done with one image - successfuly or not")
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        s.log.Fatalf("%s", err)
                }</span>
        }()
        <span class="cov0" title="0">go func(i *models.Image) </span><span class="cov0" title="0">{
                sigint := make(chan os.Signal, 1)
                signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
                sig := &lt;-sigint
                // Reload image to get updated status
                db.DB.Joins("Commit").Joins("Installer").First(&amp;i, i.ID)
                if i.Status == models.ImageStatusBuilding </span><span class="cov0" title="0">{
                        s.log.WithField("signal", sig).Info("Captured signal marking image as error", sig)
                        s.SetErrorStatusOnImage(nil, i)
                        WaitGroup.Done()
                }</span>
        }(i)

        <span class="cov0" title="0">err := s.postProcessCommit(i)
        if err != nil </span><span class="cov0" title="0">{
                s.SetErrorStatusOnImage(err, i)
                s.log.WithField("error", err.Error()).Fatal("Failed creating commit for image")
        }</span>

        <span class="cov0" title="0">if i.Commit.Status == models.ImageStatusSuccess </span><span class="cov0" title="0">{
                s.log.Debug("Commit is successful")
                // TODO: We need to discuss this whole thing post-July deliverable
                if i.HasOutputType(models.ImageTypeInstaller) </span><span class="cov0" title="0">{
                        err = s.postProcessInstaller(i)
                        if err != nil </span><span class="cov0" title="0">{
                                s.SetErrorStatusOnImage(err, i)
                                s.log.WithField("error", err.Error()).Fatal("Failed creating installer for image")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Cleaning up possible non nil installers if doesnt have output type installer
                        i.Installer = nil
                }</span>
        }
        <span class="cov0" title="0">s.log.Debug("Setting final image status")
        err = s.setFinalImageStatus(i)
        if err != nil </span><span class="cov0" title="0">{
                s.log.WithField("error", err.Error()).Fatal("Couldn't set final image status")
        }</span>
        <span class="cov0" title="0">s.log.Debug("Post processing image is done")</span>
}

// CreateRepoForImage creates the OSTree repo to host that image
func (s *ImageService) CreateRepoForImage(i *models.Image) (*models.Repo, error) <span class="cov0" title="0">{
        s.log.Infof("Creating OSTree repo.")
        repo := &amp;models.Repo{
                Status: models.RepoStatusBuilding,
        }
        tx := db.DB.Create(repo)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, tx.Error
        }</span>
        <span class="cov0" title="0">s.log = s.log.WithField("repoID", repo.ID)
        s.log.Debug("OSTree repo is created on the database")

        i.Commit.Repo = repo
        i.Commit.RepoID = &amp;repo.ID

        tx = db.DB.Save(i.Commit)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, tx.Error
        }</span>
        <span class="cov0" title="0">log.Debug("OSTree repo was saved to commit")

        repo, err := s.repoBuilder.ImportRepo(repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("OSTree repo is ready")

        return repo, nil</span>
}

// SetErrorStatusOnImage is a helper functions that sets the error status on images
func (s *ImageService) SetErrorStatusOnImage(err error, i *models.Image) <span class="cov0" title="0">{
        if i.Status != models.ImageStatusError </span><span class="cov0" title="0">{
                i.Status = models.ImageStatusError
                tx := db.DB.Save(i)
                s.log.Debug("Image saved with error status")
                if tx.Error != nil </span><span class="cov0" title="0">{
                        s.log.Error(tx.Error)
                        panic(tx.Error)</span>
                }
                <span class="cov0" title="0">if i.Commit != nil </span><span class="cov0" title="0">{
                        i.Commit.Status = models.ImageStatusError
                        tx := db.DB.Save(i.Commit)
                        if tx.Error != nil </span><span class="cov0" title="0">{
                                s.log.Error(tx.Error)
                                panic(tx.Error)</span>
                        }
                }
                <span class="cov0" title="0">if i.Installer != nil </span><span class="cov0" title="0">{
                        i.Installer.Status = models.ImageStatusError
                        tx := db.DB.Save(i.Installer)
                        if tx.Error != nil </span><span class="cov0" title="0">{
                                s.log.Error(tx.Error)
                                panic(tx.Error)</span>
                        }
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        s.log.Error(err)
                        panic(err)</span>
                }
        }
}

// AddUserInfo downloads the ISO
// injects the kickstart with username and ssh key
// and then re-uploads the ISO into our bucket
func (s *ImageService) AddUserInfo(image *models.Image) error <span class="cov0" title="0">{
        // Absolute path for manipulating ISO's
        destPath := "/var/tmp/"

        downloadURL := image.Installer.ImageBuildISOURL
        sshKey := image.Installer.SSHKey
        username := image.Installer.Username
        // Files that will be used to modify the ISO and will be cleaned
        imageName := destPath + image.Name
        kickstart := fmt.Sprintf("%sfinalKickstart-%s_%d.ks", destPath, image.Account, image.ID)

        err := s.downloadISO(imageName, downloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error downloading ISO file :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.addSSHKeyToKickstart(sshKey, username, kickstart)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error adding ssh key to kickstart file :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.exeInjectionScript(kickstart, imageName, image.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error execuiting fleetkick script :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.calculateChecksum(imageName, image)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error calculating checksum for ISO :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.uploadISO(image, imageName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error uploading ISO :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = s.cleanFiles(kickstart, imageName, image.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error cleaning files :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UnameSSH is the template struct for username and ssh key
type UnameSSH struct {
        Sshkey   string
        Username string
}

// Adds user provided ssh key to the kickstart file.
func (s *ImageService) addSSHKeyToKickstart(sshKey string, username string, kickstart string) error <span class="cov0" title="0">{
        cfg := config.Get()

        td := UnameSSH{sshKey, username}

        log.Infof("Opening file %s", cfg.TemplatesPath)
        t, err := template.ParseFiles(cfg.TemplatesPath + "templateKickstart.ks")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Infof("Creating file %s", kickstart)
        file, err := os.Create(kickstart)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Infof("Injecting username %s and key %s into template", username, sshKey)
        err = t.Execute(file, td)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">file.Close()

        return nil</span>
}

// Download created ISO into the file system.
func (s *ImageService) downloadISO(isoName string, url string) error <span class="cov0" title="0">{
        log.Infof("Creating iso %s", isoName)
        iso, err := os.Create(isoName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer iso.Close()

        log.Infof("Downloading ISO %s", url)
        res, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        _, err = io.Copy(iso, res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Upload finished ISO to S3
func (s *ImageService) uploadISO(image *models.Image, imageName string) error <span class="cov0" title="0">{

        uploadPath := fmt.Sprintf("%s/isos/%s.iso", image.Account, image.Name)
        filesService := NewFilesService()
        url, err := filesService.GetUploader().UploadFile(imageName, uploadPath)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error uploading the ISO :: %s :: %s", uploadPath, err.Error())
        }</span>

        <span class="cov0" title="0">image.Installer.ImageBuildISOURL = url
        tx := db.DB.Save(&amp;image.Installer)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Remove edited kickstart after use.
func (s *ImageService) cleanFiles(kickstart string, isoName string, imageID uint) error <span class="cov0" title="0">{
        err := os.Remove(kickstart)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Info("Kickstart file " + kickstart + " removed!")

        err = os.Remove(isoName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Info("ISO file " + isoName + " removed!")

        workDir := fmt.Sprintf("/var/tmp/workdir%d", imageID)
        err = os.RemoveAll(workDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Info("work dir file " + workDir + " removed!")

        return nil</span>
}

// UpdateImageStatus updates the status of an commit and/or installer based on Image Builder's status
func (s *ImageService) UpdateImageStatus(image *models.Image) (*models.Image, error) <span class="cov0" title="0">{
        if image.Commit.Status == models.ImageStatusBuilding </span><span class="cov0" title="0">{
                image, err := s.imageBuilder.GetCommitStatus(image)
                if err != nil </span><span class="cov0" title="0">{
                        return image, err
                }</span>
                <span class="cov0" title="0">if image.Commit.Status != models.ImageStatusBuilding </span><span class="cov0" title="0">{
                        tx := db.DB.Save(&amp;image.Commit)
                        if tx.Error != nil </span><span class="cov0" title="0">{
                                return image, tx.Error
                        }</span>
                }
        }
        <span class="cov0" title="0">if image.Installer != nil &amp;&amp; image.Installer.Status == models.ImageStatusBuilding </span><span class="cov0" title="0">{
                image, err := s.imageBuilder.GetInstallerStatus(image)
                if err != nil </span><span class="cov0" title="0">{
                        return image, err
                }</span>
                <span class="cov0" title="0">if image.Installer.Status != models.ImageStatusBuilding </span><span class="cov0" title="0">{
                        tx := db.DB.Save(&amp;image.Installer)
                        if tx.Error != nil </span><span class="cov0" title="0">{
                                return image, tx.Error
                        }</span>
                }
        }
        <span class="cov0" title="0">if image.Status != models.ImageStatusBuilding </span><span class="cov0" title="0">{
                tx := db.DB.Save(&amp;image)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return image, tx.Error
                }</span>
        }
        <span class="cov0" title="0">return image, nil</span>
}

// CheckImageName returns false if the image doesnt exist and true if the image exists
func (s *ImageService) CheckImageName(name, account string) (bool, error) <span class="cov0" title="0">{
        var imageFindByName *models.Image
        result := db.DB.Where("name = ? AND account = ?", name, account).First(&amp;imageFindByName)
        if result.Error != nil </span><span class="cov0" title="0">{
                if result.Error == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, result.Error</span>
        }
        <span class="cov0" title="0">return imageFindByName != nil, nil</span>
}

// Inject the custom kickstart into the iso via script.
func (s *ImageService) exeInjectionScript(kickstart string, image string, imageID uint) error <span class="cov0" title="0">{
        fleetBashScript := "/usr/local/bin/fleetkick.sh"
        workDir := fmt.Sprintf("/var/tmp/workdir%d", imageID)
        err := os.Mkdir(workDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(fleetBashScript, kickstart, image, image, workDir)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">log.Infof("fleetkick output: %s\n", output)
        return nil</span>
}

// Calculate the checksum of the final ISO.
func (s *ImageService) calculateChecksum(isoPath string, image *models.Image) error <span class="cov0" title="0">{
        log.Infof("Calculating sha256 checksum for ISO %s", isoPath)

        fh, err := os.Open(isoPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer fh.Close()

        sumCalculator := sha256.New()
        _, err = io.Copy(sumCalculator, fh)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">image.Installer.Checksum = hex.EncodeToString(sumCalculator.Sum(nil))
        log.Infof("Checksum (sha256): %s", image.Installer.Checksum)
        tx := db.DB.Save(&amp;image.Installer)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//ImageDetail return the structure to inform package info to images
type ImageDetail struct {
        Image              *models.Image `json:"image"`
        AdditionalPackages int           `json:"additional_packages"`
        Packages           int           `json:"packages"`
        UpdateAdded        int           `json:"update_added"`
        UpdateRemoved      int           `json:"update_removed"`
        UpdateUpdated      int           `json:"update_updated"`
}

// AddPackageInfo return info related to packages on image
func (s *ImageService) AddPackageInfo(image *models.Image) (ImageDetail, error) <span class="cov0" title="0">{
        var imgDetail ImageDetail
        imgDetail.Image = image
        imgDetail.Packages = len(image.Commit.InstalledPackages)
        imgDetail.AdditionalPackages = len(image.Packages)

        upd, err := s.GetUpdateInfo(*image)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error getting update info: %v", err)
                return imgDetail, err
        }</span>
        <span class="cov0" title="0">if upd != nil </span><span class="cov0" title="0">{
                imgDetail.UpdateAdded = len(upd[len(upd)-1].PackageDiff.Removed)
                imgDetail.UpdateRemoved = len(upd[len(upd)-1].PackageDiff.Added)
                imgDetail.UpdateUpdated = len(upd[len(upd)-1].PackageDiff.Upgraded)
        }</span> else<span class="cov0" title="0"> {
                imgDetail.UpdateAdded = 0
                imgDetail.UpdateRemoved = 0
                imgDetail.UpdateUpdated = 0
        }</span>
        <span class="cov0" title="0">return imgDetail, nil</span>
}

func addImageExtraData(image *models.Image) (*models.Image, error) <span class="cov0" title="0">{
        if image.InstallerID != nil </span><span class="cov0" title="0">{
                result := db.DB.First(&amp;image.Installer, image.InstallerID)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return nil, result.Error
                }</span>
        }
        <span class="cov0" title="0">err := db.DB.Model(image).Association("Packages").Find(&amp;image.Packages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return image, nil</span>
}

// GetImageByID retrieves an image by its identifier
func (s *ImageService) GetImageByID(imageID string) (*models.Image, error) <span class="cov3" title="2">{
        var image models.Image
        account, err := common.GetAccountFromContext(s.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, new(AccountNotSet)
        }</span>
        <span class="cov3" title="2">id, err := strconv.Atoi(imageID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, new(IDMustBeInteger)
        }</span>
        <span class="cov3" title="2">result := db.DB.Preload("Commit.Repo").Preload("Commit.InstalledPackages").Where("images.account = ?", account).Joins("Commit").First(&amp;image, id)
        if result.Error != nil </span><span class="cov3" title="2">{
                return nil, new(ImageNotFoundError)
        }</span>
        <span class="cov0" title="0">s.AddPackageInfo(&amp;image)
        return addImageExtraData(&amp;image)</span>
}

// GetImageByOSTreeCommitHash retrieves an image by its ostree commit hash
func (s *ImageService) GetImageByOSTreeCommitHash(commitHash string) (*models.Image, error) <span class="cov3" title="2">{
        var image models.Image
        account, err := common.GetAccountFromContext(s.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, new(AccountNotSet)
        }</span>
        <span class="cov3" title="2">result := db.DB.Where("images.account = ? and os_tree_commit = ?", account, commitHash).Joins("Commit").First(&amp;image)
        if result.Error != nil </span><span class="cov3" title="2">{
                return nil, new(ImageNotFoundError)
        }</span>
        <span class="cov0" title="0">return addImageExtraData(&amp;image)</span>
}

// RetryCreateImage retries the whole post process of the image creation
func (s *ImageService) RetryCreateImage(image *models.Image) error <span class="cov0" title="0">{
        s.log = s.log.WithFields(log.Fields{"imageID": image.ID, "commitID": image.Commit.ID})
        // recompose commit
        image, err := s.imageBuilder.ComposeCommit(image)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed recomposing commit")
                return err
        }</span>
        <span class="cov0" title="0">err = s.setBuildingStatusOnImageToRetryBuild(image)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed setting image status")
                return nil
        }</span>
        <span class="cov0" title="0">go s.postProcessImage(image.ID)
        return nil</span>
}

func (s *ImageService) setBuildingStatusOnImageToRetryBuild(image *models.Image) error <span class="cov1" title="1">{
        image.Status = models.ImageStatusBuilding
        if image.Commit != nil </span><span class="cov1" title="1">{
                image.Commit.Status = models.ImageStatusBuilding
                // Repo will be recreated from scratch, its safer and simpler as this stage
                if image.Commit.Repo != nil </span><span class="cov0" title="0">{
                        image.Commit.Repo = nil
                        tx := db.DB.Save(image.Commit.Repo)
                        if tx.Error != nil </span><span class="cov0" title="0">{
                                return tx.Error
                        }</span>
                }
                <span class="cov1" title="1">tx := db.DB.Save(image.Commit)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return tx.Error
                }</span>
        }
        <span class="cov1" title="1">if image.Installer != nil </span><span class="cov1" title="1">{
                image.Installer.Status = models.ImageStatusCreated
                tx := db.DB.Save(image.Installer)
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return tx.Error
                }</span>
        }
        <span class="cov1" title="1">tx := db.DB.Save(image)
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov1" title="1">return nil</span>
}
func uploadTarRepo(account, imageName string, repoID int) (string, error) <span class="cov0" title="0">{
        log.Infof(":: uploadTarRepo Started ::\n")
        uploadPath := fmt.Sprintf("%s/tar/%v/%s", account, repoID, imageName)
        filesService := NewFilesService()
        url, err := filesService.GetUploader().UploadFile(imageName, uploadPath)

        if err != nil </span><span class="cov0" title="0">{
                return "error", fmt.Errorf("error uploading the Tar :: %s :: %s", uploadPath, err.Error())
        }</span>
        <span class="cov0" title="0">log.Infof(":: uploadTarRepo Finish ::\n")

        return url, nil</span>
}

//GetUpdateInfo return package info when has an update to the image
func (s *ImageService) GetUpdateInfo(image models.Image) ([]ImageUpdateAvailable, error) <span class="cov0" title="0">{
        var images []models.Image
        var imageDiff []ImageUpdateAvailable
        updates := db.DB.Where("Image_set_id = ? and Images.Status = ? and Images.Id &lt; ?",
                image.ImageSetID, models.ImageStatusSuccess, image.ID).Joins("Commit").
                Order("Images.updated_at desc").Find(&amp;images)

        if updates.Error != nil </span><span class="cov0" title="0">{
                return nil, new(UpdateNotFoundError)
        }</span>
        <span class="cov0" title="0">if updates.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">for _, upd := range images </span><span class="cov0" title="0">{
                db.DB.First(&amp;upd.Commit, upd.CommitID)
                db.DB.Model(&amp;upd.Commit).Association("InstalledPackages").Find(&amp;upd.Commit.InstalledPackages)
                db.DB.Model(&amp;upd).Association("Packages").Find(&amp;upd.Packages)
                var delta ImageUpdateAvailable
                diff := getDiffOnUpdate(image, upd)
                upd.Commit.InstalledPackages = nil // otherwise the frontend will get the whole list of installed packages
                delta.Image = upd
                delta.PackageDiff = diff
                imageDiff = append(imageDiff, delta)
        }</span>
        <span class="cov0" title="0">return imageDiff, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/models"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
        log "github.com/sirupsen/logrus"
)

// ImageSetsServiceInterface defines the interface that helps handle
// the business logic of ImageSets
type ImageSetsServiceInterface interface {
        ListAllImageSets(w http.ResponseWriter, r *http.Request) error
        GetImageSetsByID(imageSetID int) (*models.ImageSet, error)
}

// NewImageSetsService gives a instance of the main implementation of a ImageSetsServiceInterface
func NewImageSetsService(ctx context.Context) ImageSetsServiceInterface <span class="cov0" title="0">{
        return &amp;ImageSetsService{
                ctx: ctx,
        }
}</span>

// ImageSetsService is the main implementation of a ImageSetsServiceInterface
type ImageSetsService struct {
        ctx context.Context
}

// ListAllImageSets to org group of images into one
func (s *ImageSetsService) ListAllImageSets(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{

        var imageFilters = common.ComposeFilters(
                common.OneOfFilterHandler(&amp;common.Filter{
                        QueryParam: "status",
                        DBField:    "images.status",
                }),
                common.ContainFilterHandler(&amp;common.Filter{
                        QueryParam: "name",
                        DBField:    "images.name",
                }),
                common.ContainFilterHandler(&amp;common.Filter{
                        QueryParam: "distribution",
                        DBField:    "images.distribution",
                }),
                common.CreatedAtFilterHandler(&amp;common.Filter{
                        QueryParam: "created_at",
                        DBField:    "images.created_at",
                }),
                common.SortFilterHandler("images", "created_at", "DESC"),
        )
        var count int64
        var images []models.Image
        var image models.Image
        result := imageFilters(r, db.DB)
        pagination := common.GetPagination(r)

        countResult := imageFilters(r, db.DB.Model(&amp;models.Image{})).Where("images.Image_set_id  is ?", image.ImageSetID).Count(&amp;count)
        if countResult.Error != nil </span><span class="cov0" title="0">{
                countErr := errors.NewInternalServerError()
                log.Error(countErr)
                w.WriteHeader(countErr.GetStatus())
                json.NewEncoder(w).Encode(&amp;countErr)
        }</span>
        <span class="cov0" title="0">result = result.Limit(pagination.Limit).Offset(pagination.Offset).Where("images.Image_set_id  is ?", image.ImageSetID).Find(&amp;images)
        if result.Error != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                w.WriteHeader(err.GetStatus())
                json.NewEncoder(w).Encode(&amp;err)
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{"data": &amp;images, "count": count})
        return nil</span>
}

// GetImageSetsByID to get image set by id
func (s *ImageSetsService) GetImageSetsByID(imageSetID int) (*models.ImageSet, error) <span class="cov8" title="1">{
        var imageSet models.ImageSet
        result := db.DB.Where("Image_sets.id = ?", imageSetID).Find(&amp;imageSet)
        db.DB.Where("image_set_id = ?", imageSetID).Find(&amp;imageSet.Images)
        if result.Error != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;imageSet, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package services

import (
        "context"
        "errors"

        libfdo "github.com/fedora-iot/fido-device-onboard-rs/libfdo-data-go"
        "github.com/redhatinsights/edge-api/pkg/clients/fdo"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"
        log "github.com/sirupsen/logrus"
        "gorm.io/gorm"
)

// OwnershipVoucherService for ownership voucher management
type OwnershipVoucherService struct {
        ctx context.Context
        log *log.Entry
}

// OwnershipVoucherServiceInterface is the interface for the ownership voucher service
type OwnershipVoucherServiceInterface interface {
        BatchUploadOwnershipVouchers(voucherBytes []byte, numOfOVs uint) (interface{}, error)
        BatchDeleteOwnershipVouchers(fdoUUIDList []string) (interface{}, error)
        ConnectDevices(fdoUUIDList []string) ([]interface{}, []error)
        ParseOwnershipVouchers(voucherBytes []byte) ([]models.OwnershipVoucherData, error)
        GetFDODeviceByGUID(ownershipVoucherGUID string) (*models.FDODevice, error)
        GetOwnershipVouchersByGUID(ownershipVoucherGUID string) (*models.OwnershipVoucherData, error)
        GetFDOUserByGUID(ownershipVoucherGUID string) (*models.FDOUser, error)
        storeFDODevices(data []models.OwnershipVoucherData)
        removeFDODevices(fdoUUIDList []string)
        parseVouchers(voucherBytes []byte) ([]models.OwnershipVoucherData, error)
        createFDOClient() *fdo.Client
}

// NewOwnershipVoucherService creates a new ownership voucher service
func NewOwnershipVoucherService(ctx context.Context, log *log.Entry) OwnershipVoucherServiceInterface <span class="cov2" title="2">{
        return &amp;OwnershipVoucherService{
                ctx: ctx,
                log: log.WithField("service", "ownershipvoucher"),
        }
}</span>

// BatchUploadOwnershipVouchers creates empty devices with ownership vouchers data
func (ovs *OwnershipVoucherService) BatchUploadOwnershipVouchers(voucherBytes []byte, numOfOVs uint) (interface{}, error) <span class="cov3" title="3">{
        logFields := log.Fields{"method": "services.BatchUploadOwnershipVouchers"}
        ovs.log.WithFields(logFields).Debug("Creating ownership vouchers")
        data, err := ovs.ParseOwnershipVouchers(voucherBytes)
        if err != nil </span><span class="cov1" title="1">{
                ovs.log.WithFields(logFields).Error("Failed to parse ownership vouchers")
                return nil, err
        }</span>
        <span class="cov2" title="2">ovs.log.WithFields(logFields).Debug("Creating FDO client")
        fdoClient := ovs.createFDOClient()
        resp, err := fdoClient.BatchUpload(voucherBytes, numOfOVs)
        if err != nil </span><span class="cov1" title="1">{
                ovs.log.WithFields(logFields).Error("Failed to upload ownership vouchers to the FDO server")
                return resp, err
        }</span>
        <span class="cov1" title="1">ovs.storeFDODevices(data)
        return resp, nil</span>
}

// BatchDeleteOwnershipVouchers deletes ownership vouchers from the FDO server
func (ovs *OwnershipVoucherService) BatchDeleteOwnershipVouchers(fdoUUIDList []string) (interface{}, error) <span class="cov2" title="2">{
        logFields := log.Fields{"method": "services.BatchDeleteOwnershipVouchers"}
        ovs.log.WithFields(logFields).Debug("Deleting ownership vouchers")
        fdoClient := ovs.createFDOClient()
        resp, err := fdoClient.BatchDelete(fdoUUIDList)
        ovs.removeFDODevices(fdoUUIDList)
        return resp, err
}</span>

// ConnectDevices API point for the FDO server to connect devices
func (ovs *OwnershipVoucherService) ConnectDevices(fdoUUIDList []string) (resp []interface{}, errList []error) <span class="cov3" title="3">{
        logFields := log.Fields{"method": "services.ConnectDevices"}
        ovs.log.WithFields(logFields).Debug("Connecting devices")
        for _, guid := range fdoUUIDList </span><span class="cov5" title="7">{
                fdoDevice, err := ovs.GetFDODeviceByGUID(guid)
                if err != nil </span><span class="cov2" title="2">{
                        ovs.log.WithFields(logFields).Warn("Couldn't find OwnershipVoucher ", guid, err)
                        errList = append(errList, errors.New(guid))
                }</span> else<span class="cov4" title="5"> {
                        fdoDevice.Connected = true
                        resp = append(resp, map[string]string{"guid": guid})
                        db.DB.Save(&amp;fdoDevice)
                }</span>
        }
        <span class="cov3" title="3">return</span>
}

// ParseOwnershipVouchers reads ownership vouchers from bytes
func (ovs *OwnershipVoucherService) ParseOwnershipVouchers(voucherBytes []byte) ([]models.OwnershipVoucherData, error) <span class="cov4" title="5">{
        logFields := log.Fields{"method": "services.ParseOwnershipVouchers"}
        ovs.log.WithFields(logFields).Debug("Parsing ownership vouchers")
        data, err := ovs.parseVouchers(voucherBytes)
        if err != nil </span><span class="cov2" title="2">{
                ovs.log.WithFields(logFields).Error("Failed to parse ownership vouchers")
                return nil, err
        }</span>
        <span class="cov3" title="3">return data, nil</span>
}

// GetFDODeviceByGUID receives GUID string and get a *models.FDODevice back
func (ovs *OwnershipVoucherService) GetFDODeviceByGUID(ownershipVoucherGUID string) (*models.FDODevice, error) <span class="cov9" title="32">{
        logFields := log.Fields{"method": "services.GetFDODeviceByGUID"}
        ovs.log.WithFields(logFields).Debug("Getting FDO device by GUID")
        // get the FDO device from the database
        var fdoDevice models.FDODevice
        result := joinWithFDODevices(ownershipVoucherGUID).First(&amp;fdoDevice)
        if result.Error != nil </span><span class="cov2" title="2">{
                ovs.log.WithFields(logFields).Error("Failed to get FDO device by GUID ", result.Error)
                return nil, result.Error
        }</span>
        // get the ownership voucher data related to the FDO device
        <span class="cov9" title="30">ov, err := ovs.GetOwnershipVouchersByGUID(ownershipVoucherGUID)
        if err != nil </span><span class="cov4" title="5">{
                ovs.log.WithFields(logFields).Error("Failed to get ownership voucher by GUID ", err)
                return nil, err
        }</span>
        <span class="cov8" title="25">fdoDevice.OwnershipVoucherData = ov

        // get the FDO user related to the FDO device
        fdoUser, err := ovs.GetFDOUserByGUID(ownershipVoucherGUID)
        if err != nil </span><span class="cov0" title="0">{
                ovs.log.WithFields(logFields).Error("Failed to get FDO user by FDO device ", err)
                return nil, err
        }</span>
        <span class="cov8" title="25">fdoDevice.InitialUser = fdoUser
        return &amp;fdoDevice, nil</span>
}

// GetOwnershipVouchersByGUID receives GUID string and get a *models.OwnershipVoucherData back
func (ovs *OwnershipVoucherService) GetOwnershipVouchersByGUID(ownershipVoucherGUID string) (*models.OwnershipVoucherData, error) <span class="cov10" title="42">{
        logFields := log.Fields{"method": "services.GetOwnershipVouchersByGUID"}
        ovs.log.WithFields(logFields).Debug("Getting ownership vouchers by GUID")
        var ov models.OwnershipVoucherData
        result := db.DB.Where("guid = ?", ownershipVoucherGUID).First(&amp;ov)
        if result.Error != nil </span><span class="cov6" title="12">{
                ovs.log.WithFields(logFields).Error("Failed to get ownership vouchers by GUID ", result.Error)
                return nil, result.Error
        }</span>
        <span class="cov9" title="30">return &amp;ov, nil</span>
}

// GetFDOUserByGUID receives an ownership voucher GUID and get a *models.FDOUser back
func (ovs *OwnershipVoucherService) GetFDOUserByGUID(ownershipVoucherGUID string) (*models.FDOUser, error) <span class="cov9" title="37">{
        logFields := log.Fields{"method": "services.GetFDOUserByFDODevice"}
        ovs.log.WithFields(logFields).Debug("Getting FDO user by FDO device")
        var fdoUser models.FDOUser
        result := db.DB.Joins("JOIN ownership_voucher_data ON ownership_voucher_data.fdo_device_id = fdo_users.fdo_device_id and ownership_voucher_data.guid = ?",
                ownershipVoucherGUID).First(&amp;fdoUser)
        if result.Error != nil </span><span class="cov5" title="7">{
                ovs.log.WithFields(logFields).Error("Failed to get FDO user by FDO device ", result.Error)
                return nil, result.Error
        }</span>
        <span class="cov9" title="30">return &amp;fdoUser, nil</span>
}

// storeFDODevices stores FDO devices to the database
func (ovs *OwnershipVoucherService) storeFDODevices(data []models.OwnershipVoucherData) <span class="cov2" title="2">{
        logFields := log.Fields{"method": "services.storeFDODevices"}
        ovs.log.WithFields(logFields).Debug("Store empty devices, with FDO info")
        for _, voucherData := range data </span><span class="cov5" title="6">{
                fdoDevice := models.FDODevice{
                        OwnershipVoucherData: &amp;voucherData,
                        InitialUser:          &amp;models.FDOUser{},
                }
                result := joinWithFDODevices(voucherData.GUID).FirstOrCreate(&amp;fdoDevice)
                if result.Error != nil </span><span class="cov0" title="0">{
                        ovs.log.WithFields(logFields).Error("Failed to store FDO device ", result.Error)
                }</span>
        }
}

// removeFDODevices removes FDO devices from the database
func (ovs *OwnershipVoucherService) removeFDODevices(fdoUUIDList []string) <span class="cov3" title="3">{
        logFields := log.Fields{"method": "services.removeFDODevices"}
        for _, guid := range fdoUUIDList </span><span class="cov5" title="7">{
                // Delete the OwnershipVoucherData associated with the FDO device is enough to remove the FDO device
                ov, err := ovs.GetOwnershipVouchersByGUID(guid)
                if err != nil </span><span class="cov2" title="2">{
                        ovs.log.WithFields(logFields).Error("Failed to get ownership voucher by GUID ", guid)
                }</span>
                // Delete the FDO user associated with the FDO device
                <span class="cov5" title="7">fdoUser, err := ovs.GetFDOUserByGUID(guid)
                if err != nil </span><span class="cov2" title="2">{
                        ovs.log.WithFields(logFields).Error("Failed to get FDO user by FDO device ", guid)
                }</span>
                <span class="cov5" title="7">db.DB.Delete(ov)
                db.DB.Delete(fdoUser)</span>
        }
}

// parseVouchers parses vouchers from a byte array, returning the data and error if any
func (ovs *OwnershipVoucherService) parseVouchers(voucherBytes []byte) ([]models.OwnershipVoucherData, error) <span class="cov4" title="5">{
        logFields := log.Fields{"method": "services.parseVouchers"}
        vouchers, err := libfdo.ParseManyOwnershipVouchers(voucherBytes)
        if err != nil </span><span class="cov2" title="2">{
                ovs.log.WithFields(logFields).Error("Failed to parse vouchers ", err)
                return nil, err
        }</span>
        <span class="cov3" title="3">defer vouchers.Free()

        var data []models.OwnershipVoucherData
        for i := 0; i &lt; vouchers.Len(); i++ </span><span class="cov3" title="3">{
                voucher, err := vouchers.GetVoucher(i)
                if err != nil </span><span class="cov0" title="0">{
                        ovs.log.WithFields(logFields).Error("Failed to get voucher ", err)
                        return nil, err
                }</span>
                <span class="cov3" title="3">data = append(data, models.OwnershipVoucherData{
                        GUID:            voucher.GetGUID(),
                        ProtocolVersion: voucher.GetProtocolVersion(),
                        DeviceName:      voucher.GetDeviceInfo(),
                })</span>
        }
        <span class="cov3" title="3">return data, nil</span>
}

// createFDOClient creates a new FDO client
func (ovs *OwnershipVoucherService) createFDOClient() *fdo.Client <span class="cov4" title="4">{
        return fdo.InitClient(ovs.ctx, ovs.log)
}</span>

// help function to join OwnershipVoucherData &amp; FDOUser with FDODevices
func joinWithFDODevices(guid string) *gorm.DB <span class="cov9" title="38">{
        return db.DB.Joins("JOIN ownership_voucher_data ON ownership_voucher_data.fdo_device_id = fdo_devices.id and ownership_voucher_data.guid = ?",
                guid).Joins("JOIN fdo_users ON fdo_users.fdo_device_id = fdo_devices.id")
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "context"

        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"
        log "github.com/sirupsen/logrus"
)

// RepoServiceInterface defines the interface to handle the business logic of RHEL for Edge Devices
type RepoServiceInterface interface {
        GetRepoByID(repoID *uint) (*models.Repo, error)
        GetRepoByCommitID(commitID uint) (*models.Repo, error)
}

// NewRepoService gives a instance of the main implementation of RepoServiceInterface
func NewRepoService(ctx context.Context) RepoServiceInterface <span class="cov10" title="4">{
        return &amp;RepoService{
                ctx: ctx,
        }
}</span>

// RepoService is the main implementation of a RepoServiceInterface
type RepoService struct {
        ctx context.Context
}

// GetRepoByID receives RepoID uint and get a *models.Repo back
func (s *RepoService) GetRepoByID(repoID *uint) (*models.Repo, error) <span class="cov0" title="0">{
        log.Debugf("GetRepoByID::repoID: %#v", repoID)
        var repo models.Repo
        result := db.DB.First(&amp;repo, repoID)
        log.Debugf("GetRepoByID::result: %#v", result)
        log.Debugf("GetRepoByID::repo: %#v", repo)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;repo, nil</span>
}

// GetRepoByCommitID receives Repo.CommitID uint and get a *models.Repo back
func (s *RepoService) GetRepoByCommitID(commitID uint) (*models.Repo, error) <span class="cov0" title="0">{
        log.Debugf("GetRepoByCommitID::commitID: %#v", commitID)
        var repo models.Repo
        result := db.DB.Where("commit_id = ?", commitID).First(&amp;repo)
        log.Debugf("GetRepoByCommitID::result: %#v", result)
        log.Debugf("GetRepoByCommitID::repo: %#v", repo)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;repo, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"

        "bytes"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"

        "github.com/cavaliercoder/grab"
        log "github.com/sirupsen/logrus"
)

// RepoBuilderInterface defines the interface of a repository builder
type RepoBuilderInterface interface {
        BuildUpdateRepo(id uint) (*models.UpdateTransaction, error)
        ImportRepo(r *models.Repo) (*models.Repo, error)
        // DownloadExtractVersionRepo(c *models.Commit, dest string) error
        DownloadVersionRepo(c *models.Commit, dest string) (string, error)
        ExtractVersionRepo(c *models.Commit, tarFileName string, dest string) error
        UploadVersionRepo(c *models.Commit, tarFileName string, dest string) error
}

// RepoBuilder is the implementation of a RepoBuilderInterface
type RepoBuilder struct {
        ctx          context.Context
        filesService FilesService
        repoService  RepoServiceInterface
        log          *log.Entry
}

// NewRepoBuilder initializes the repository builder in this package
func NewRepoBuilder(ctx context.Context, log *log.Entry) RepoBuilderInterface <span class="cov10" title="4">{
        return &amp;RepoBuilder{
                ctx:          ctx,
                filesService: NewFilesService(),
                repoService:  NewRepoService(ctx),
                log:          log,
        }
}</span>

// BuildUpdateRepo build an update repo with the set of commits all merged into a single repo
// with static deltas generated between them all
func (rb *RepoBuilder) BuildUpdateRepo(id uint) (*models.UpdateTransaction, error) <span class="cov0" title="0">{
        var update *models.UpdateTransaction
        db.DB.Preload("DispatchRecords").Preload("Devices").Joins("Commit").Joins("Repo").Find(&amp;update, id)

        log.Infof("Repobuilder::BuildUpdateRepo:: Begin")
        if update == nil </span><span class="cov0" title="0">{
                log.Error("nil pointer to models.UpdateTransaction provided")
                return nil, errors.New("invalid models.UpdateTransaction Provided: nil pointer")
        }</span>
        <span class="cov0" title="0">if update.Commit == nil </span><span class="cov0" title="0">{
                log.Error("nil pointer to models.UpdateTransaction.Commit provided")
                return nil, errors.New("invalid models.UpdateTransaction.Commit Provided: nil pointer")
        }</span>
        <span class="cov0" title="0">if update.Repo == nil </span><span class="cov0" title="0">{
                log.Errorf("updateFromHTTP::Update:Repo is unavailable %#v", update.ID)
                return nil, errors.New("repo unavailable")
        }</span>
        <span class="cov0" title="0">cfg := config.Get()

        log.Infof("RepoBuilder::updateCommitID %d and UpdateTransactionID %d", update.Commit.ID, update.ID)

        path := filepath.Join(cfg.RepoTempPath, "upd/", strconv.FormatUint(uint64(update.ID), 10))
        log.Infof("RepoBuilder::path: %#v", path)
        err := os.MkdirAll(path, os.FileMode(int(0755)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = os.Chdir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // err = rb.DownloadExtractVersionRepo(update.Commit, path)
        // if err != nil {
        //         return nil, fmt.Errorf("error downloading repo :: %s", err.Error())
        // }
        <span class="cov0" title="0">tarFileName, err := rb.DownloadVersionRepo(update.Commit, path)
        if err != nil </span><span class="cov0" title="0">{

                return nil, fmt.Errorf("error Upload repo repo :: %s", err.Error())
        }</span>
        <span class="cov0" title="0">err = rb.ExtractVersionRepo(update.Commit, tarFileName, path)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return nil, fmt.Errorf("error extracting repo :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(update.OldCommits) &gt; 0 </span><span class="cov0" title="0">{
                stagePath := filepath.Join(path, "staging")
                err = os.MkdirAll(stagePath, os.FileMode(int(0755)))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error mkdir :: %s", err.Error())
                }</span>
                <span class="cov0" title="0">err = os.Chdir(stagePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error chdir :: %s", err.Error())
                }</span>

                // If there are any old commits, we need to download them all to be merged
                // into the update commit repo
                //
                // FIXME: hardcoding "repo" in here because that's how it comes from osbuild
                <span class="cov0" title="0">for _, commit := range update.OldCommits </span><span class="cov0" title="0">{
                        // rb.DownloadExtractVersionRepo(&amp;commit, filepath.Join(stagePath, commit.OSTreeCommit))
                        // if err != nil {
                        //         return nil, err
                        // }
                        tarFileName, err := rb.DownloadVersionRepo(&amp;commit, filepath.Join(stagePath, commit.OSTreeCommit))
                        if err != nil </span><span class="cov0" title="0">{

                                return nil, fmt.Errorf("error Upload repo repo :: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">err = rb.ExtractVersionRepo(update.Commit, tarFileName, path)
                        RepoPullLocalStaticDeltas(update.Commit, &amp;commit, filepath.Join(path, "repo"), filepath.Join(stagePath, commit.OSTreeCommit, "repo"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Once all the old commits have been pulled into the update commit's repo
                // and has static deltas generated, then we don't need the old commits
                // anymore.
                <span class="cov0" title="0">err = os.RemoveAll(stagePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }
        // FIXME: Need to actually do something with the return string for Server

        // NOTE: This relies on the file path being cfg.RepoTempPath/models.Repo.ID/
        <span class="cov0" title="0">log.Infof("::BuildUpdateRepo:uploader.UploadRepo: BEGIN")
        repoURL, err := rb.filesService.GetUploader().UploadRepo(filepath.Join(path, "repo"), strconv.FormatUint(uint64(update.ID), 10))
        log.Infof("::BuildUpdateRepo:uploader.UploadRepo: FINISH")
        log.Infof("::BuildUpdateRepo:repoURL: %#v", repoURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">update.Repo.URL = repoURL
        update.Repo.Status = models.RepoStatusSuccess
        if err := db.DB.Save(&amp;update).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := db.DB.Save(&amp;update.Repo).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return update, nil</span>
}

// ImportRepo (unpack and upload) a single repo
func (rb *RepoBuilder) ImportRepo(r *models.Repo) (*models.Repo, error) <span class="cov0" title="0">{

        var cmt models.Commit
        cmtDB := db.DB.Where("repo_id = ?", r.ID).Find(&amp;cmt)
        if cmtDB.Error != nil </span><span class="cov0" title="0">{
                return nil, cmtDB.Error
        }</span>
        <span class="cov0" title="0">cfg := config.Get()
        path := filepath.Join(cfg.RepoTempPath, strconv.FormatUint(uint64(r.ID), 10))
        log.Debugf("RepoBuilder::path: %#v", path)
        err := os.MkdirAll(path, os.FileMode(int(0755)))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = os.Chdir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tarFileName, err := rb.DownloadVersionRepo(&amp;cmt, path)
        errUpload := rb.UploadVersionRepo(&amp;cmt, tarFileName, path)
        if errUpload != nil </span><span class="cov0" title="0">{
                r.Status = models.RepoStatusError
                result := db.DB.Save(&amp;r)
                if result.Error != nil </span><span class="cov0" title="0">{
                        log.Error(err)
                }</span>
                <span class="cov0" title="0">log.Error(err)
                return nil, fmt.Errorf("error Upload repo repo :: %s", errUpload.Error())</span>
        }
        <span class="cov0" title="0">err = rb.ExtractVersionRepo(&amp;cmt, tarFileName, path)
        if err != nil </span><span class="cov0" title="0">{
                r.Status = models.RepoStatusError
                result := db.DB.Save(&amp;r)
                if result.Error != nil </span><span class="cov0" title="0">{
                        log.Error(err)
                }</span>
                <span class="cov0" title="0">log.Error(err)
                return nil, fmt.Errorf("error extracting repo :: %s", err.Error())</span>
        }
        // NOTE: This relies on the file path being cfg.RepoTempPath/models.Repo.ID/
        <span class="cov0" title="0">repoURL, err := rb.filesService.GetUploader().UploadRepo(filepath.Join(path, "repo"), strconv.FormatUint(uint64(r.ID), 10))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return nil, fmt.Errorf("error uploading repo :: %s", err.Error())
        }</span>

        <span class="cov0" title="0">r.URL = repoURL
        r.Status = models.RepoStatusSuccess
        result := db.DB.Save(&amp;r)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error saving status :: %s", result.Error.Error())
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}

// DownloadVersionRepo Download and Extract the repo tarball to dest dir
func (rb *RepoBuilder) DownloadVersionRepo(c *models.Commit, dest string) (string, error) <span class="cov0" title="0">{
        // ensure we weren't passed a nil pointer
        if c == nil </span><span class="cov0" title="0">{
                log.Error("nil pointer to models.Commit provided")
                return "", errors.New("invalid Commit Provided: nil pointer")
        }</span>
        <span class="cov0" title="0">log.Debugf("DownloadExtractVersionRepo::CommitID: %d", c.ID)

        // ensure the destination directory exists and then chdir there
        log.Debugf("DownloadExtractVersionRepo::dest: %#v", dest)
        err := os.MkdirAll(dest, os.FileMode(int(0755)))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">err = os.Chdir(dest)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Save the tarball to the OSBuild Hash ID and then extract it
        <span class="cov0" title="0">tarFileName := "repo.tar"
        if c.ImageBuildHash != "" </span><span class="cov0" title="0">{
                tarFileName = strings.Join([]string{c.ImageBuildHash, "tar"}, ".")
        }</span>
        <span class="cov0" title="0">log.Debugf("DownloadExtractVersionRepo::tarFileName: %#v", tarFileName)
        _, err = grab.Get(filepath.Join(dest, tarFileName), c.ImageBuildTarURL)

        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return "", err
        }</span>
        <span class="cov0" title="0">log.Debugf("Download finished::tarFileName: %#v", tarFileName)

        return tarFileName, nil</span>
}

// UploadVersionRepo Upload the repo tarball to the repo service
func (rb *RepoBuilder) UploadVersionRepo(c *models.Commit, tarFileName string, dest string) error <span class="cov0" title="0">{
        //Upload ImageBuildTar to repo
        log.Debugf("UploadVersionRepo::CommitID: %d", c.ID)
        repoTarURL, errorUpl := uploadTarRepo(c.Account, tarFileName, int(*c.RepoID))
        c.ImageBuildTarURL = repoTarURL
        log.Debugf("Finish UploadVersionRepo::CommitID: %d", c.ID)
        if errorUpl != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to open file: %s", filepath.Join(dest, tarFileName))
                log.Error(errorUpl)
                return errorUpl
        }</span>
        <span class="cov0" title="0">result := db.DB.Save(c)
        log.Debugf("Save tarRepo to ::CommitID: %d", c.ID)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ExtractVersionRepo Download and Extract the repo tarball to dest dir
func (rb *RepoBuilder) ExtractVersionRepo(c *models.Commit, tarFileName string, dest string) error <span class="cov0" title="0">{

        tarFile, err := os.Open(filepath.Join(dest, tarFileName))

        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to open file: %s", filepath.Join(dest, tarFileName))
                log.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">err = rb.filesService.GetExtractor().Extract(tarFile, filepath.Join(dest))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to untar file: %s", filepath.Join(dest, tarFileName))
                log.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">tarFile.Close()
        log.Debugf("Unpacking tarball finished::tarFileName: %#v", tarFileName)

        err = os.Remove(filepath.Join(dest, tarFileName))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to remove file: %s", filepath.Join(dest, tarFileName))
                log.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">var cmd *exec.Cmd
        if c.OSTreeRef == "" </span><span class="cov0" title="0">{
                cfg := config.Get()
                cmd = exec.Command("ostree", "--repo", "./repo", "commit", cfg.DefaultOSTreeRef, "--add-metadata-string", fmt.Sprintf("version=%s.%d", c.BuildDate, c.BuildNumber))
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("ostree", "--repo", "./repo", "commit", c.OSTreeRef, "--add-metadata-string", fmt.Sprintf("version=%s.%d", c.BuildDate, c.BuildNumber))
        }</span>
        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("'ostree --repo ./ commit --add-metadata-string' command failed", err)
                log.Errorf("Failed Command: %s %s %s %s %s %s %s", "ostree", "--repo", "./repo", "commit", c.OSTreeRef, "--add-metadata-string", fmt.Sprintf("version=%s.%d", c.BuildDate, c.BuildNumber))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RepoPullLocalStaticDeltas pull local repo into the new update repo and compute static deltas
//  uprepo should be where the update commit lives, u is the update commit
//  oldrepo should be where the old commit lives, o is the commit to be merged
func RepoPullLocalStaticDeltas(u *models.Commit, o *models.Commit, uprepo string, oldrepo string) error <span class="cov0" title="0">{
        err := os.Chdir(uprepo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">updateRevParse, err := RepoRevParse(uprepo, u.OSTreeRef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">oldRevParse, err := RepoRevParse(oldrepo, o.OSTreeRef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // pull the local repo at the exact rev (which was HEAD of o.OSTreeRef)
        <span class="cov0" title="0">cmd := exec.Command("ostree", "--repo", uprepo, "pull-local", oldrepo, oldRevParse)
        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // generate static delta
        <span class="cov0" title="0">cmd = exec.Command("ostree", "--repo", uprepo, "static-delta", "generate", "--from", oldRevParse, "--to", updateRevParse)
        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>

}

// RepoRevParse Handle the RevParse separate since we need the stdout parsed
func RepoRevParse(path string, ref string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("ostree", "rev-parse", "--repo", path, ref)

        var res bytes.Buffer
        cmd.Stdout = &amp;res

        err := cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(res.String()), nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "context"

        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/errors"
        "github.com/redhatinsights/edge-api/pkg/models"
        "github.com/redhatinsights/edge-api/pkg/routes/common"
        log "github.com/sirupsen/logrus"
)

// ThirdPartyRepoServiceInterface defines the interface that helps handles
// the business logic of creating Third Party Repository
type ThirdPartyRepoServiceInterface interface {
        CreateThirdPartyRepo(tprepo *models.ThirdPartyRepo, account string) (*models.ThirdPartyRepo, error)
        GetThirdPartyRepoByID(ID string) (*models.ThirdPartyRepo, error)
        UpdateThirdPartyRepo(tprepo *models.ThirdPartyRepo, account string, ID string) error
        DeleteThirdPartyRepoByID(ID string) (*models.ThirdPartyRepo, error)
}

// NewThirdPartyRepoService gives a instance of the main implementation of a ThirdPartyRepoServiceInterface
func NewThirdPartyRepoService(ctx context.Context) ThirdPartyRepoServiceInterface <span class="cov0" title="0">{
        return &amp;ThirdPartyRepoService{
                ctx: ctx,
        }
}</span>

// ThirdPartyRepoService is the main implementation of a ThirdPartyRepoServiceInterface
type ThirdPartyRepoService struct {
        ctx context.Context
}

// CreateThirdPartyRepo creates the ThirdPartyRepo for an Account on our database
func (s *ThirdPartyRepoService) CreateThirdPartyRepo(thirdPartyRepo *models.ThirdPartyRepo, account string) (*models.ThirdPartyRepo, error) <span class="cov0" title="0">{
        if thirdPartyRepo.URL != "" &amp;&amp; thirdPartyRepo.Name != "" </span><span class="cov0" title="0">{
                thirdPartyRepo = &amp;models.ThirdPartyRepo{
                        Name:        thirdPartyRepo.Name,
                        URL:         thirdPartyRepo.URL,
                        Description: thirdPartyRepo.Description,
                        Account:     account,
                }
                result := db.DB.Create(&amp;thirdPartyRepo)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return nil, result.Error
                }</span>
                <span class="cov0" title="0">log.Infof("Getting ThirdPartyRepo info: repo %s, %s", thirdPartyRepo.URL, thirdPartyRepo.Name)</span>

        }
        <span class="cov0" title="0">return thirdPartyRepo, nil</span>
}

// GetThirdPartyRepoByID gets the Third Party Repository by ID from the database
func (s *ThirdPartyRepoService) GetThirdPartyRepoByID(ID string) (*models.ThirdPartyRepo, error) <span class="cov0" title="0">{
        var tprepo models.ThirdPartyRepo
        account, err := common.GetAccountFromContext(s.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, new(AccountNotSet)
        }</span>
        <span class="cov0" title="0">result := db.DB.Where("account = ? and id = ?", account, ID).First(&amp;tprepo)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, new(ThirdPartyRepositoryNotFound)
        }</span>
        <span class="cov0" title="0">return &amp;tprepo, nil</span>
}

// UpdateThirdPartyRepo updates the existing third party repository
func (s *ThirdPartyRepoService) UpdateThirdPartyRepo(tprepo *models.ThirdPartyRepo, account string, ID string) error <span class="cov0" title="0">{

        tprepo.Account = account
        repoDetails, err := s.GetThirdPartyRepoByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
        }</span>
        <span class="cov0" title="0">if tprepo.Name != "" </span><span class="cov0" title="0">{
                repoDetails.Name = tprepo.Name
        }</span>

        <span class="cov0" title="0">if tprepo.URL != "" </span><span class="cov0" title="0">{
                repoDetails.URL = tprepo.URL
        }</span>

        <span class="cov0" title="0">if tprepo.Description != "" </span><span class="cov0" title="0">{
                repoDetails.Description = tprepo.Description
        }</span>
        <span class="cov0" title="0">result := db.DB.Save(&amp;repoDetails)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteThirdPartyRepoByID deletes the third party repository using ID
func (s *ThirdPartyRepoService) DeleteThirdPartyRepoByID(ID string) (*models.ThirdPartyRepo, error) <span class="cov0" title="0">{
        var tprepo models.ThirdPartyRepo
        account, err := common.GetAccountFromContext(s.ctx)
        result := db.DB.Where("id = ?", ID).First(&amp;tprepo)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, new(ThirdPartyRepositoryNotFound)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, new(AccountNotSet)
        }</span>
        <span class="cov0" title="0">repoDetails, err := s.GetThirdPartyRepoByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Info(err)
        }</span>
        <span class="cov0" title="0">if repoDetails.Name == "" </span><span class="cov0" title="0">{
                return nil, errors.NewInternalServerError()
        }</span>

        <span class="cov0" title="0">delForm := db.DB.Where("account = ? and id = ?", account, ID).Delete(&amp;tprepo)
        if delForm.Error != nil </span><span class="cov0" title="0">{
                err := errors.NewInternalServerError()
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tprepo, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "strings"
        "syscall"
        "text/template"
        "time"

        "github.com/redhatinsights/edge-api/config"
        "github.com/redhatinsights/edge-api/pkg/clients/playbookdispatcher"
        "github.com/redhatinsights/edge-api/pkg/db"
        "github.com/redhatinsights/edge-api/pkg/models"
        log "github.com/sirupsen/logrus"
)

// UpdateServiceInterface defines the interface that helps
// handle the business logic of sending updates to a edge device
type UpdateServiceInterface interface {
        CreateUpdate(id uint) (*models.UpdateTransaction, error)
        GetUpdatePlaybook(update *models.UpdateTransaction) (io.ReadCloser, error)
        GetUpdateTransactionsForDevice(device *models.Device) (*[]models.UpdateTransaction, error)
        ProcessPlaybookDispatcherRunEvent(message []byte) error
        WriteTemplate(templateInfo TemplateRemoteInfo, account string) (string, error)
        SetUpdateStatusBasedOnDispatchRecord(dispatchRecord models.DispatchRecord) error
        SetUpdateStatus(update *models.UpdateTransaction) error
}

// NewUpdateService gives a instance of the main implementation of a UpdateServiceInterface
func NewUpdateService(ctx context.Context) UpdateServiceInterface <span class="cov6" title="4">{
        return &amp;UpdateService{
                Context:       ctx,
                FilesService:  NewFilesService(),
                RepoBuilder:   NewRepoBuilder(ctx, log.NewEntry(log.StandardLogger())),
                WaitForReboot: time.Minute * 5,
        }
}</span>

// UpdateService is the main implementation of a UpdateServiceInterface
type UpdateService struct {
        Context       context.Context
        RepoBuilder   RepoBuilderInterface
        FilesService  FilesService
        WaitForReboot time.Duration
}

type playbooks struct {
        GoTemplateRemoteName string
        GoTemplateGpgVerify  string
        OstreeRemoteName     string
        OstreeGpgVerify      string
        OstreeGpgKeypath     string
        FleetInfraEnv        string
        UpdateNumber         string
        RepoURL              string
}

// TemplateRemoteInfo the values to playbook
type TemplateRemoteInfo struct {
        RemoteName          string
        RemoteURL           string
        ContentURL          string
        GpgVerify           string
        UpdateTransactionID uint
}

// PlaybookDispatcherEventPayload belongs to PlaybookDispatcherEvent
type PlaybookDispatcherEventPayload struct {
        ID            string `json:"id"`
        Account       string `json:"account"`
        Recipient     string `json:"recipient"`
        CorrelationID string `json:"correlation_id"`
        Service       string `json:"service"`
        URL           string `json:"url"`
        Labels        struct {
                ID      string `json:"id"`
                StateID string `json:"state_id"`
        } `json:"labels"`
        Status    string    `json:"status"`
        Timeout   int       `json:"timeout"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// PlaybookDispatcherEvent is the event that gets sent to the Kafka broker when a update finishes
type PlaybookDispatcherEvent struct {
        EventType string                         `json:"event_type"`
        Payload   PlaybookDispatcherEventPayload `json:"payload"`
}

// CreateUpdate is the function that creates an update transaction
func (s *UpdateService) CreateUpdate(id uint) (*models.UpdateTransaction, error) <span class="cov1" title="1">{
        var update *models.UpdateTransaction
        db.DB.Preload("DispatchRecords").Preload("Devices").Joins("Commit").Joins("Repo").Find(&amp;update, id)
        update.Status = models.UpdateStatusBuilding
        db.DB.Save(&amp;update)

        WaitGroup.Add(1) // Processing one update
        defer func() </span><span class="cov1" title="1">{
                WaitGroup.Done() // Done with one update (successfuly or not)
                log.Debug("Done with one update - successfuly or not")
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("%s", err)
                }</span>
        }()
        <span class="cov1" title="1">go func(update *models.UpdateTransaction) </span><span class="cov1" title="1">{
                sigint := make(chan os.Signal, 1)
                signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
                sig := &lt;-sigint
                // Reload update to get updated status
                db.DB.First(&amp;update, update.ID)
                if update.Status == models.UpdateStatusBuilding </span><span class="cov0" title="0">{
                        log.WithFields(log.Fields{
                                "signal":   sig,
                                "updateID": update.ID,
                        }).Info("Captured signal marking update as error")
                        update.Status = models.UpdateStatusError
                        tx := db.DB.Save(update)
                        if tx.Error != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Error saving update: %s", tx.Error.Error())
                        }</span>
                        <span class="cov0" title="0">WaitGroup.Done()</span>
                }
        }(update)

        <span class="cov1" title="1">update, err := s.RepoBuilder.BuildUpdateRepo(id)
        if err != nil </span><span class="cov1" title="1">{
                db.DB.First(&amp;update, id)
                update.Status = models.UpdateStatusError
                db.DB.Save(update)
                log.Error(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var remoteInfo TemplateRemoteInfo
        remoteInfo.RemoteURL = update.Repo.URL
        remoteInfo.RemoteName = "rhel-edge"
        remoteInfo.ContentURL = update.Repo.URL
        remoteInfo.UpdateTransactionID = update.ID
        remoteInfo.GpgVerify = "false"
        playbookURL, err := s.WriteTemplate(remoteInfo, update.Account)
        if err != nil </span><span class="cov0" title="0">{
                update.Status = models.UpdateStatusError
                db.DB.Save(update)
                log.Error(err)
                return nil, err
        }</span>
        // 3. Loop through all devices in UpdateTransaction
        <span class="cov0" title="0">dispatchRecords := update.DispatchRecords
        for _, device := range update.Devices </span><span class="cov0" title="0">{
                // Create new &amp;DispatcherPayload{}
                payloadDispatcher := playbookdispatcher.DispatcherPayload{
                        Recipient:   device.RHCClientID,
                        PlaybookURL: playbookURL,
                        Account:     update.Account,
                }
                log.Infof("Call Execute Dispatcher: : %#v", payloadDispatcher)
                client := playbookdispatcher.InitClient(s.Context)
                exc, err := client.ExecuteDispatcher(payloadDispatcher)

                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Error on playbook-dispatcher execution: %#v ", err)
                        update.Status = models.UpdateStatusError
                        db.DB.Save(update)
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, excPlaybook := range exc </span><span class="cov0" title="0">{
                        if excPlaybook.StatusCode == http.StatusCreated </span><span class="cov0" title="0">{
                                device.Connected = true
                                dispatchRecord := &amp;models.DispatchRecord{
                                        Device:               &amp;device,
                                        PlaybookURL:          playbookURL,
                                        Status:               models.DispatchRecordStatusCreated,
                                        PlaybookDispatcherID: excPlaybook.PlaybookDispatcherID,
                                }
                                dispatchRecords = append(dispatchRecords, *dispatchRecord)
                        }</span> else<span class="cov0" title="0"> {
                                device.Connected = false
                                dispatchRecord := &amp;models.DispatchRecord{
                                        Device:      &amp;device,
                                        PlaybookURL: playbookURL,
                                        Status:      models.DispatchRecordStatusError,
                                }
                                dispatchRecords = append(dispatchRecords, *dispatchRecord)
                        }</span>
                        <span class="cov0" title="0">db.DB.Save(&amp;device)</span>
                }
                <span class="cov0" title="0">update.DispatchRecords = dispatchRecords
                err = s.SetUpdateStatus(update)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Error saving update: %s ", err.Error())
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">log.Infof("Update was finished for :: %d", update.ID)
        return update, nil</span>
}

// GetUpdatePlaybook is the function that returns the path to an update playbook
func (s *UpdateService) GetUpdatePlaybook(update *models.UpdateTransaction) (io.ReadCloser, error) <span class="cov0" title="0">{
        fname := fmt.Sprintf("playbook_dispatcher_update_%s_%d.yml", update.Account, update.ID)
        path := fmt.Sprintf("%s/playbooks/%s", update.Account, fname)
        return s.FilesService.GetFile(path)
}</span>

func (s *UpdateService) getPlaybookURL(updateID uint) string <span class="cov1" title="1">{
        cfg := config.Get()
        url := fmt.Sprintf("%s/api/edge/v1/updates/%d/update-playbook.yml",
                cfg.EdgeAPIBaseURL, updateID)
        return url
}</span>

// WriteTemplate is the function that writes the template to a file
func (s *UpdateService) WriteTemplate(templateInfo TemplateRemoteInfo, account string) (string, error) <span class="cov1" title="1">{
        cfg := config.Get()
        filePath := cfg.TemplatesPath
        templateName := "template_playbook_dispatcher_ostree_upgrade_payload.yml"
        templateContents, err := template.New(templateName).Delims("@@", "@@").ParseFiles(filePath + templateName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error parsing playbook template  :: %s", err.Error())
                return "", err
        }</span>
        <span class="cov1" title="1">var envName string
        if strings.Contains(cfg.BucketName, "-prod") || strings.Contains(cfg.BucketName, "-stage") || strings.Contains(cfg.BucketName, "-perf") </span><span class="cov0" title="0">{
                bucketNameSplit := strings.Split(cfg.BucketName, "-")
                envName = bucketNameSplit[len(bucketNameSplit)-1]
        }</span> else<span class="cov1" title="1"> {
                envName = "dev"
        }</span>
        <span class="cov1" title="1">templateData := playbooks{
                GoTemplateRemoteName: templateInfo.RemoteName,
                FleetInfraEnv:        envName,
                UpdateNumber:         strconv.FormatUint(uint64(templateInfo.UpdateTransactionID), 10),
                RepoURL:              "https://{{ s3_buckets[fleet_infra_env] | default('rh-edge-tarballs-prod') }}.s3.us-east-1.amazonaws.com/{{ update_number }}/upd/{{ update_number }}/repo",
        }

        fname := fmt.Sprintf("playbook_dispatcher_update_%s_%d.yml", account, templateInfo.UpdateTransactionID)
        tmpfilepath := fmt.Sprintf("/tmp/%s", fname)
        f, err := os.Create(tmpfilepath)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error creating file: %s", err.Error())
                return "", err
        }</span>
        <span class="cov1" title="1">err = templateContents.Execute(f, templateData)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error executing template: %s ", err.Error())
                return "", err
        }</span>

        <span class="cov1" title="1">uploadPath := fmt.Sprintf("%s/playbooks/%s", account, fname)
        playbookURL, err := s.FilesService.GetUploader().UploadFile(tmpfilepath, uploadPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error uploading file to S3: %s ", err.Error())
                return "", err
        }</span>
        <span class="cov1" title="1">log.Infof("Template file uploaded to S3, URL: %s", playbookURL)
        err = os.Remove(tmpfilepath)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Fail silently, find a way to create alerts based on this log
                // The container will end up out of space if we don't fix it in the long run.
                log.Errorf("Error deleting temp file: %s ", err.Error())
        }</span>
        <span class="cov1" title="1">playbookURL = s.getPlaybookURL(templateInfo.UpdateTransactionID)
        log.Infof("Proxied playbook URL: %s", playbookURL)
        log.Infof("::WriteTemplate: ENDs")
        return playbookURL, nil</span>
}

// GetUpdateTransactionsForDevice returns all update transactions for a given device
func (s *UpdateService) GetUpdateTransactionsForDevice(device *models.Device) (*[]models.UpdateTransaction, error) <span class="cov3" title="2">{
        var updates []models.UpdateTransaction
        result := db.DB.
                Table("update_transactions").
                Joins(
                        `JOIN updatetransaction_devices ON update_transactions.id = updatetransaction_devices.update_transaction_id`).
                Where(`updatetransaction_devices.device_id = ?`,
                        device.ID,
                ).Group("id").Order("id").Find(&amp;updates)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov3" title="2">return &amp;updates, nil</span>
}

// Status defined by https://github.com/RedHatInsights/playbook-dispatcher/blob/master/schema/run.event.yaml
const (
        // PlaybookStatusRunning is the status when a playbook is still running
        PlaybookStatusRunning = "running"
        // PlaybookStatusSuccess is the status when a playbook has run successfully
        PlaybookStatusSuccess = "success"
        // PlaybookStatusFailure is the status when a playbook execution fails
        PlaybookStatusFailure = "failure"
        // PlaybookStatusFailure is the status when a playbook execution times out
        PlaybookStatusTimeout = "timeout"
)

// ProcessPlaybookDispatcherRunEvent is the method that processes messages from playbook dispatcher to set update statuses
func (s *UpdateService) ProcessPlaybookDispatcherRunEvent(message []byte) error <span class="cov8" title="6">{
        var e *PlaybookDispatcherEvent
        err := json.Unmarshal(message, &amp;e)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="6">log := log.WithFields(log.Fields{
                "PlaybookDispatcherID": e.Payload.ID,
                "Status":               e.Payload.Status,
        })
        if e.Payload.Status == PlaybookStatusRunning </span><span class="cov0" title="0">{
                log.Debug("Playbook is running - waiting for next messages")
                return nil
        }</span> else<span class="cov8" title="6"> if e.Payload.Status == PlaybookStatusSuccess </span><span class="cov6" title="4">{
                log.Debug("The playbook was applied successfully. Waiting two minutes for reboot before setting status to success.")
                time.Sleep(s.WaitForReboot)
        }</span>

        <span class="cov8" title="6">var dispatchRecord models.DispatchRecord
        result := db.DB.Where(&amp;models.DispatchRecord{PlaybookDispatcherID: e.Payload.ID}).First(&amp;dispatchRecord)
        if result.Error != nil </span><span class="cov1" title="1">{
                return result.Error
        }</span>

        <span class="cov7" title="5">if e.Payload.Status == PlaybookStatusFailure || e.Payload.Status == PlaybookStatusTimeout </span><span class="cov3" title="2">{
                dispatchRecord.Status = models.DispatchRecordStatusError
        }</span> else<span class="cov5" title="3"> if e.Payload.Status == PlaybookStatusSuccess </span><span class="cov5" title="3">{
                // TODO: We might wanna check if it's really success by checking the running hash on the device here
                dispatchRecord.Status = models.DispatchRecordStatusComplete
        }</span> else<span class="cov0" title="0"> if e.Payload.Status == PlaybookStatusRunning </span><span class="cov0" title="0">{
                dispatchRecord.Status = models.DispatchRecordStatusRunning
        }</span> else<span class="cov0" title="0"> {
                dispatchRecord.Status = models.DispatchRecordStatusError
                log.Fatal("Playbook status is not on the json schema for this event")
        }</span>
        <span class="cov7" title="5">result = db.DB.Save(&amp;dispatchRecord)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov7" title="5">return s.SetUpdateStatusBasedOnDispatchRecord(dispatchRecord)</span>
}

// SetUpdateStatusBasedOnDispatchRecord is the function that, given a dispatch record, finds the update transaction related to and update its status if necessary
func (s *UpdateService) SetUpdateStatusBasedOnDispatchRecord(dispatchRecord models.DispatchRecord) error <span class="cov7" title="5">{
        var update models.UpdateTransaction
        result := db.DB.Preload("DispatchRecords").
                Table("update_transactions").
                Joins(
                        `JOIN updatetransaction_dispatchrecords ON update_transactions.id = updatetransaction_dispatchrecords.update_transaction_id`).
                Where(`updatetransaction_dispatchrecords.dispatch_record_id = ?`,
                        dispatchRecord.ID,
                ).First(&amp;update)
        if result.Error != nil </span><span class="cov1" title="1">{
                return result.Error
        }</span>

        <span class="cov6" title="4">return s.SetUpdateStatus(&amp;update)</span>

}

// SetUpdateStatus is the function to set the update status from an UpdateTransaction
func (s *UpdateService) SetUpdateStatus(update *models.UpdateTransaction) error <span class="cov8" title="7">{
        allSuccess := true

        for _, d := range update.DispatchRecords </span><span class="cov10" title="9">{
                if d.Status != models.DispatchRecordStatusComplete </span><span class="cov6" title="4">{
                        allSuccess = false
                }</span>
                <span class="cov10" title="9">if d.Status == models.DispatchRecordStatusError </span><span class="cov5" title="3">{
                        update.Status = models.UpdateStatusError
                        break</span>
                }
        }
        <span class="cov8" title="7">if allSuccess </span><span class="cov5" title="3">{
                update.Status = models.UpdateStatusSuccess
        }</span>
        // If there isn't an error and it's not all success, some updates are still happening
        <span class="cov8" title="7">result := db.DB.Save(update)
        return result.Error</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
